<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://dlfelps.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://dlfelps.github.io/" rel="alternate" type="text/html" /><updated>2024-05-26T01:03:00+00:00</updated><id>https://dlfelps.github.io/feed.xml</id><title type="html">.NET Experiments</title><subtitle>Bill Nye meets Bill Gates ;)</subtitle><author><name>Daniel Felps</name><email>dlfelps@gmail.com</email></author><entry><title type="html">Experiment 17</title><link href="https://dlfelps.github.io/2024/06/04/explainable.html" rel="alternate" type="text/html" title="Experiment 17" /><published>2024-06-04T00:00:00+00:00</published><updated>2024-06-04T00:00:00+00:00</updated><id>https://dlfelps.github.io/2024/06/04/explainable</id><content type="html" xml:base="https://dlfelps.github.io/2024/06/04/explainable.html"><![CDATA[<p>This post introduces Concept Bottleneck Models - an interpretable approach to machine learning.</p>

<h2 id="introduction">Introduction</h2>

<h3 id="conclusion">Conclusion</h3>

<p>The code for this experiment can be found at my <a href="https://github.com/dlfelps/ml_portfolio">ML portfolio website</a>.</p>]]></content><author><name>Daniel Felps</name><email>dlfelps@gmail.com</email></author><category term="explainable" /><category term="interpretable" /><category term="computer-vision" /><category term="ml-portfolio" /><summary type="html"><![CDATA[This post introduces Concept Bottleneck Models - an interpretable approach to machine learning.]]></summary></entry><entry><title type="html">Experiment 16</title><link href="https://dlfelps.github.io/2024/06/03/few-shot.html" rel="alternate" type="text/html" title="Experiment 16" /><published>2024-06-03T00:00:00+00:00</published><updated>2024-06-03T00:00:00+00:00</updated><id>https://dlfelps.github.io/2024/06/03/few-shot</id><content type="html" xml:base="https://dlfelps.github.io/2024/06/03/few-shot.html"><![CDATA[<p>This post explores unique concepts in few-shot learning.</p>

<h2 id="introduction">Introduction</h2>

<p>Few-shot learning describes the situation where a classifier must generalize to new classes using only a small number of examples of each new class. It represents scenarios where data collection (or annotation) is costly for the classes you care about, but you have access to similar data. There are some unique terms associated with few-shot learning, which we will introduce next.</p>

<p>In standard supervised learning, the training and testing sets contain the SAME classes. The classifier is tested for its ability to discriminate between KNOWN classes.</p>

<p><img src="/assets/images/supervised_learning.PNG" alt="supervised learning" title="supervised learning" /></p>

<p><a href="https://ieeexplore.ieee.org/document/10287966">image reference</a></p>

<p>In few-shot learning, the training and testing sets contain DIFFERENT classes. A few-shot classifier is tested for its ability to discriminate UNKNOWN classes given only a few examples. These samples are further divided into the support set and query set. The support set contains labeled examples (for tuning the few-shot classifier) and the query set contains unlabeled samples for evaluation. The number of classes in the support set is denoted by N and the number of examples per class is denoted by K. A 5-way 1-shot method describes a method that has (N=5) classes with (K=1) examples per class.</p>

<p><img src="/assets/images/few_shot_learning.PNG" alt="few_shot_learning" title="few_shot_learning" /></p>

<p><a href="https://ieeexplore.ieee.org/document/10287966">image reference</a></p>

<h2 id="episodic-training-meta-learning">Episodic training (meta-learning)</h2>
<p>(comparison with transfer learning approach)
https://arxiv.org/pdf/2204.11181
 To simulate generalization challenges at test times, such strategies build sequences of artificially balanced few-shot tasks (or episodes) during base training, each containing both query and support samples.</p>

<p>https://arxiv.org/pdf/1703.05175
Vinyals et al. [29] proposed matching networks, which uses an attention mechanism over a learned embedding of the
labeled set of examples (the support set) to predict classes for the unlabeled points (the query set).
Matching networks can be interpreted as a weighted nearest-neighbor classifier applied within an
embedding space. Notably, this model utilizes sampled mini-batches called episodes during training,
where each episode is designed to mimic the few-shot task by subsampling classes as well as data
points. The use of episodes makes the training problem more faithful to the test environment and
thereby improves generalization.</p>

<h2 id="transductive-vs-inductive-learning-based-approaches">Transductive vs inductive learning-based approaches</h2>
<p>https://arxiv.org/pdf/2204.11181
 In few-shot learning, transductive inference has access to exactly the same training and testing data as its inductive counterpart3 . The difference is that it classifies all the unlabeled query samples of each single few-shot task jointly, rather than one sample at a time.</p>

<p>https://arxiv.org/pdf/1805.10002
One way to achieve larger improvements with limited amount of training
data is to consider relationships between instances in the test set and thus predicting them as a whole,
which is referred to as transduction, or transductive inference. In previous work (Joachims, 1999;
Zhou et al., 2004; Vapnik, 1999), transductive inference has shown to outperform inductive methods
which predict test examples one by one, especially in small training sets</p>

<p>https://en.wikipedia.org/wiki/Transduction_(machine_learning)
 transductive inference is reasoning from observed, specific (training) cases to specific (test) cases. In contrast, induction is reasoning from observed training cases to general rules, which are then applied to the test cases</p>

<h1 id="experiment">Experiment</h1>

<h2 id="cub-dataset">CUB dataset</h2>

<h2 id="prototype-model">Prototype model</h2>

<h3 id="relationship-to-image-retrieval">relationship to image retrieval</h3>
<p>https://arxiv.org/pdf/1904.04232v2
baseline++ prototype</p>

<h3 id="conclusion">Conclusion</h3>

<p>The code for this experiment can be found at my <a href="https://github.com/dlfelps/ml_portfolio">ML portfolio website</a>.</p>]]></content><author><name>Daniel Felps</name><email>dlfelps@gmail.com</email></author><category term="few-shot" /><category term="computer-vision" /><category term="ml-portfolio" /><category term="meta-learning" /><summary type="html"><![CDATA[This post explores unique concepts in few-shot learning.]]></summary></entry><entry><title type="html">Experiment 15</title><link href="https://dlfelps.github.io/2024/06/02/VIT-amster.html" rel="alternate" type="text/html" title="Experiment 15" /><published>2024-06-02T00:00:00+00:00</published><updated>2024-06-02T00:00:00+00:00</updated><id>https://dlfelps.github.io/2024/06/02/VIT-amster</id><content type="html" xml:base="https://dlfelps.github.io/2024/06/02/VIT-amster.html"><![CDATA[<p>This post explores DINOv2 - a foundational vision model from FAIR.</p>

<h2 id="introduction">Introduction</h2>

<p>Yann LeCun is one of the godfathers of deep learning<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>. He believes that one of the most critical challenges to solve in the current era is how to give AI systems common sense. Common sense is difficult to define, but I believe that it keeps me alive and allows me to learn new skills helps with relatively few attempts (compared to deep learning). LeCun calls this elusive knowledge the dark matter of AI.</p>

<p>How do we impart this knowledge to our AI systems? LeCun believes the solution lies in self-supervised learning. Self-supervised learning is a technique that adapts tasks that conventionally require labels into an unsupervised learning task (e.g. next word prediction). Self-supervised learning tasks can take advantage of massive amounts of data. If designed properly, the model will learn accurate, meaningful representations of the data. Large Language Models have been popular in the news lately due to their uncanny ability to achieve human-level performance on many tasks. Their sucess is due, in part, to their ability to leverage large amounts of unnannotated text through self-supervised learning.</p>

<p>It is no surprise that the most successful self-supervised computer vision models come from LeCun’s lab (Fundamental AI Research team at Meta). They published <a href="https://ai.meta.com/blog/dino-paws-computer-vision-with-self-supervised-transformers-and-10x-more-efficient-training/">DINO (2021)</a> and <a href="https://ai.meta.com/blog/dino-v2-computer-vision-self-supervised-learning/">DINOv2 (2023)</a> as foundational image models. Foundational models are meant to serve as a resusable backbone for many tasks.</p>

<p><img src="/assets/images/dinov2.png" alt="DINO" title="DINO" />
<a href="https://aipapersacademy.com/dinov2-from-meta-ai-finally-a-foundational-model-in-computer-vision/">source</a></p>

<h2 id="image-retrieval">Image retrieval</h2>

<p>In their <a href="https://arxiv.org/abs/2304.07193">paper</a>, DINOv2 is benchmarked against many SOTA computer vision tasks. One of those tasks is image retrieval. Image retrieval uses images to search for other relevant images. It can help users discover new images guided by visual similarity. Popular benchmarks for image retrieval methods include the <a href="https://paperswithcode.com/dataset/oxford5k">Oxford building</a> and <a href="https://paperswithcode.com/dataset/google-landmarks-dataset-v2">Google Landmarks</a>. In this post I wanted to explore a dataset that was designed to retrieve images through time - the <a href="https://paperswithcode.com/dataset/amstertime">AmsterTime</a> dataset.</p>

<h3 id="amstertime-dataset">AmsterTime dataset</h3>

<p>The AmsterTime dataset offers a collection of 2,500 well-curated images matching the same scene from a street view matched to historical archival image data from Amsterdam city. This is a challenging dataset for image retrieval because the query and gallery sets were taken many years apart so there is often structural changes for the same location.</p>

<p><img src="/assets/images/amstertime.PNG" alt="AmsterTime" title="AmsterTime" /></p>

<h3 id="image-retrieval-with-dinov2">Image retrieval with DINOv2</h3>

<p>Finding similar images with DINOv2 is simple. First, compute the embedding vector for each image in the gallery by passing it through the DINOv2 model. Then, given a query image, compare its embedding vector with those from the gallery using cosine similarity:</p>

<p><img src="/assets/images/cosine.svg" alt="cosine" title="cosine" /></p>

<h4 id="the-embedding-vector">The embedding vector</h4>

<p>DINOv2 is a vision transformer model. As such, it transforms an image into patches and processes those patches a sequence of patches.</p>

<p><img src="/assets/images/vit.png" alt="vit" title="vit" />
<a href="https://arxiv.org/abs/2010.11929v2">source</a></p>

<p>The sequence is processed by the model and the embedding vector referenced here refers to the [CLS] token of the final layer (represented by the “*” in the figure above). Since the [CLS] token does not represent an actual token, the transformer learns to encode a general representation of the entire image into that token. One of the most desirable  features of DINOv2 is that the attention maps associated with the [CLS] token of the last layer tend to be aligned with salient foreground objects (i.e. the model is attending to the primary subject of the image). It is worth looking at the code to see how to extract the [CLS] token:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def get_cls_token_for_images(images, processor, model):

  collect = []

  for i in tqdm(images):
    inputs = processor(images=i, return_tensors="pt")
    with torch.no_grad():
      outputs = model(**inputs)
    last_hidden_states = outputs.last_hidden_state
    collect.append(last_hidden_states[:,0,:]) # cls token

  return torch.cat(collect)
</code></pre></div></div>

<h2 id="results">Results</h2>

<p>A common metric for reporting results in image retrieval is Recall@N. Here are the results for the AmsterTime dataset:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">query</th>
      <th style="text-align: center">gallery</th>
      <th style="text-align: center">recall@1</th>
      <th style="text-align: center">recall@5</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">AmsterTime</td>
      <td style="text-align: center">archival</td>
      <td style="text-align: center">streetview</td>
      <td style="text-align: center">0.43</td>
      <td style="text-align: center">0.68</td>
    </tr>
  </tbody>
</table>

<p>Not bad considering the difficulty of the dataset. This means that 43% of the time the top matching image is the correct one. Let’s look at some of the cases where this worked well (query image on left, correct result from gallery on right).</p>

<p><img src="/assets/images/match_on.png" alt="TP" title="TP" /></p>

<p>It is also informative to look at the cases where the approach failed. Below are the top-10 worst performing queries (largest distances between query and gallery). Each row contains the query image, the top predicted result, and finally the correct result.</p>

<p><img src="/assets/images/mismatch_on.png" alt="FP" title="FP" /></p>

<p>We see that many of the correct results contain occlusions or severe camera distortions, preventing the structural features of the building from being matched. In most of the cases, it is difficult for even a human to match the images.</p>

<p>Since the AmsterTime dataset contains pairs of images across time (1250 archival, 1250 streetview) we can also reverse the gallery and query sets. Surprisingly, its easier to predict the future than the past ;)</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">query</th>
      <th style="text-align: center">gallery</th>
      <th style="text-align: center">recall@1</th>
      <th style="text-align: center">recall@5</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">AmsterTime</td>
      <td style="text-align: center">archival</td>
      <td style="text-align: center">streetview</td>
      <td style="text-align: center">0.43</td>
      <td style="text-align: center">0.68</td>
    </tr>
    <tr>
      <td style="text-align: center">AmsterTime</td>
      <td style="text-align: center">streetview</td>
      <td style="text-align: center">archival</td>
      <td style="text-align: center">0.35</td>
      <td style="text-align: center">0.57</td>
    </tr>
  </tbody>
</table>

<h3 id="conclusion">Conclusion</h3>

<p>This post demonstrated the potential power of the DINOv2 foundational vision model. The results show that the model is capable of capturing the salient information in an image retrieval task without any prior training. The code for this experiment can be found at my <a href="https://github.com/dlfelps/ml_portfolio">ML portfolio website</a>.</p>

<h4 id="footnotes">Footnotes</h4>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Yoshua Bengio and Geoffrey Hinton are also given this title. In 2018 LeCun, Bengio, and Hinton won the <a href="https://www.acm.org/media-center/2019/march/turing-award-2018">Turing award</a> for their contributions in deep learing. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Daniel Felps</name><email>dlfelps@gmail.com</email></author><category term="vit" /><category term="computer-vision" /><category term="image-retrieval" /><category term="ml-portfolio" /><category term="self-supervised" /><summary type="html"><![CDATA[This post explores DINOv2 - a foundational vision model from FAIR.]]></summary></entry><entry><title type="html">Experiment 14</title><link href="https://dlfelps.github.io/2024/06/01/quantum-smalltalk5.html" rel="alternate" type="text/html" title="Experiment 14" /><published>2024-06-01T00:00:00+00:00</published><updated>2024-06-01T00:00:00+00:00</updated><id>https://dlfelps.github.io/2024/06/01/quantum-smalltalk5</id><content type="html" xml:base="https://dlfelps.github.io/2024/06/01/quantum-smalltalk5.html"><![CDATA[<h1 id="introduction">Introduction</h1>
<p>Our final post in the Quantum Smalltalk series explores a thought experiment proposed by Avshalom Elitzur and Lev Vaidman to demonstrate an unusual quantum feature - interaction-free measurement.</p>

<h1 id="experiment-14">Experiment #14</h1>
<p>Elitzur and  Vaidman proposed the following thought experiment:</p>

<blockquote>
  <p>You are given 100 EV bombs. Due to a manufacturing problem that was caught too late, some of the triggers are defective. Your job is to try to salvage as many good bombs as possible.</p>
</blockquote>

<h2 id="what-is-an-ev-bomb">What is an EV Bomb?</h2>
<p>This experiment requires us to add a new piece of equipment to our workbench - the EV bomb. This bomb is special because it has a very sensitive trigger: a photon detector. Turn out the lights now because a single photon can cause this bomb to explode!</p>

<p>The following rules describe an EV bomb:</p>
<ol>
  <li>If the trigger is not defective, when a photon enters trigger tube the bomb explodes and you cannot salvage the bomb.</li>
  <li>If the trigger is defective, when a photon enters the trigger tube the bomb does not explode and the photon continues undisturbed out the trigger tube exit.</li>
  <li>The distance from the bomb to the rest of the equipment is sufficiently large to protect the equipment; only the bomb is destroyed if an explosion occurs.</li>
</ol>

<h2 id="attempt-1">Attempt #1</h2>
<p><img src="/assets/images/exp14.png" alt="Experiment #14" title="Experiment #14" /></p>

<p>Our first attempt to salvage the good EV bombs isn’t very clever. Let’s just shoot some photons at it and see what happens.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Count</th>
      <th style="text-align: center">Explosion</th>
      <th style="text-align: center">Photon detected at D1</th>
      <th style="text-align: center">Bombs salvaged</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">80</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td style="text-align: center">20</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">N/A</td>
    </tr>
  </tbody>
</table>

<p>We tested all the bombs and determined with 100% accuracy which ones were defective and which ones were good. However, we failed to salvage any of the good bombs because they were blown up in the process. If it seems like this thought experiment has no solution, then you are likely restricting yourself to solutions that follow the principle of locality. (For extra details on locality see Appendix B &amp; C below.)</p>

<h2 id="attempt-2">Attempt #2</h2>
<p><img src="/assets/images/exp15.png" alt="Experiment #15" title="Experiment #15" /></p>

<p>Our second attempt should look familiar by now - the Mach-Zehnder setup. We place the bomb on the path between the first beamsplitter and the lower mirror and observe the following results:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Count</th>
      <th style="text-align: center">Explosion</th>
      <th style="text-align: center">Photon detected at D0</th>
      <th style="text-align: center">Photon detected at D1</th>
      <th style="text-align: center">Bombs salvaged</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">40</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">?</td>
    </tr>
    <tr>
      <td style="text-align: center">40</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">?</td>
    </tr>
    <tr>
      <td style="text-align: center">20</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">?</td>
    </tr>
  </tbody>
</table>

<p>Clearly we can’t salvage any of the 40 good bombs that blew up. But what about the remaining 60 that didn’t explode? Were they all defective? To answer this question, let’s look at our simulation output. We first observe what happens to photons that pass through a defective EV bomb:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Emitting a photon from lower path. &gt;&gt; #(0 1)
Photon passing through a beam splitter. &gt;&gt; #(0.4999999999999999 0.4999999999999999)
Photon passes through defective EV Bomb placed on the lower path. &gt;&gt; #(0.4999999999999999 0.4999999999999999)
Photon bouncing off of a mirror. &gt;&gt; #(0.4999999999999999 0.4999999999999999)
Photon passing through a beam splitter. &gt;&gt; #(0.9999999999999996 0.0)
Photon finally detected with following probabilities: &gt;&gt; #(0.9999999999999996 0.0 )

</code></pre></div></div>

<p>Defective EV bombs act as if they aren’t there (just like Experiment #11) so there is a 100% chance that it will be detected at D0. Good EV bombs give a different result:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Emitting a photon from lower path. &gt;&gt; #(0 1)
Photon passing through a beam splitter. &gt;&gt; #(0.4999999999999999 0.4999999999999999)
Photon detonates EV Bomb on the lower path with 50% probability. &gt;&gt; #(0.4999999999999999 0)
Photon bouncing off of a mirror. &gt;&gt; #(0.0 0.4999999999999999)
Photon passing through a beam splitter. &gt;&gt; #(0.2499999999999999 0.2499999999999999)
Photon finally detected with following probabilities: &gt;&gt; #(0.2499999999999999 0.2499999999999999)
</code></pre></div></div>

<p>From the simulation we see that half of the time the EV bomb detonates. Therefore, we can deduce that there were 80 good bombs (because we observed 40 detonating) and 20 bad bombs (the remainder). The output probability for the bombs that don’t detonate is 25% at D0 and 25% at D1. This means that the 20 bombs we observed at D1 are good! The other 40 bombs that didn’t detonate and that we observed at D0 have a 50% probability of being good, but we can’t tell which is which.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Count</th>
      <th style="text-align: center">Explosion</th>
      <th style="text-align: center">Photon detected at D0</th>
      <th style="text-align: center">Photon detected at D1</th>
      <th style="text-align: center">Bombs salvaged</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">40</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td style="text-align: center">40</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td style="text-align: center">20</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">20</td>
    </tr>
  </tbody>
</table>

<h2 id="attempt-3-optional">Attempt #3 (optional)</h2>

<p>It’s a shame that we were only able to recover 25% of the good bombs. We can achieve the theoretical limit of 50% (or 40 in our example) by using something called the <a href="https://en.wikipedia.org/wiki/Quantum_Zeno_effect?useskin=vector">Quantum Zeno Effect</a>. The details of how to extend our setup using this effect are left up to the reader. I recommend <a href="https://youtu.be/fus1nJ6JaTk?si=Y6ljo3NrULArOx5H&amp;t=375">this video</a>.</p>

<p><img src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*bjGo9HLPhqvxcVbdZGnuOA.gif" alt="Quantum Zeno effect" />
<a href="https://medium.com/qiskit/building-quantum-bomb-testers-and-other-thought-experiments-with-quantum-computers-c160060fdde4">source</a></p>

<h1 id="interaction-free-measurement">Interaction-free measurement</h1>

<p>The EV bomb experiment demonstrates a non-local feature of quantum mechanics; we were able to learn something about a path that the photon didn’t take. Furthermore, we did so without any prior information. This is called an interaction-free measurement.</p>

<p>This is in contrast to, for example, the case where it is known that an object is located in one of two boxes. Looking and <em>not</em> finding it in one box tells us that the object is located inside the other box. This is also an interaction-free measurement, but it does not violate non-locality because we used prior information.</p>

<h1 id="summary">Summary</h1>
<p>Experiment #14 presented another weird quantum feature of interaction-free measurements. Although our treatment was theoretical, know that these results have been duplicated in the <a href="https://www.oeaw.ac.at/fileadmin/Institute/IQOQI-Vienna/PDF/publications-zeilinger/1994_-_Fundamental_Problems_in_Quantum_Theory_-_Experimental_Realization_of_Interaction-Free_Measurement.pdf">lab</a>.</p>

<h1 id="conclusion">Conclusion</h1>
<p>This post concludes the Quantum Smalltalk series. I am amazed at how much of the quantum world we were able to explore using the Mach-Zehnder setup. I hope that these posts piqued your interest in quantum mechanics. There are a lot of great resources available. As a next step, I recommend the book <a href="https://www.amazon.com/Through-Two-Doors-Once-Experiment/dp/1101986093">Through Two Doors at Once: The Elegant Experiment That Captures the Enigma of Our Quantum Reality</a> by Anil Ananthaswamy. Alternatively, if you find general relativity generally fascinating then you might want to explore more advanced topics like the <a href="https://en.wikipedia.org/wiki/Black_hole_information_paradox?useskin=vector">black hole information paradox</a>.</p>

<h1 id="appendix-a-the-smalltalk-code">Appendix A: The Smalltalk code</h1>
<p>The full Pharo package can be found at <a href="https://github.com/dlfelps/MZI">dlfeps/MZI</a>.</p>

<h1 id="appendix-b-einstein-and-locality">Appendix B: Einstein and locality</h1>
<p>The principle of locality states that for one point to have an effect one another point, something must travel between the points to cause the effect. The special theory of relativity limits the speed of travel to the speed of light. Therefore an event at point <strong>A</strong> cannot cause a result at point <strong>B</strong> in a time less than <strong>D/c</strong>, where <strong>D</strong> is the distance between the points and <strong>c</strong> is the speed of light in vacuum.</p>

<p>Einstein believed in locality. In one of his 1935 papers, Einstein (along with co-authors Podolsky and Rosen) describe a thought experiment that demonstrates a scenario where quantum mechanics violates locality and concluded that quantum theory does not provide a complete description of reality. The paper ends by saying:</p>

<blockquote>
  <p>“While we have thus shown that the wave function does not provide a complete description of the physical reality, we left open the question of whether or not such a description exists. We believe, however, that such a theory is possible.”</p>
</blockquote>

<p>Einstein believed that the solution to the paradox lay in introducing additional (possibly inaccessible) variables. Such a theory is known as a hidden variable theory.</p>

<h1 id="appendix-c-bell-and-locality">Appendix C: Bell and locality</h1>
<p>Almost 30 years after Einstein’s paper, John Stewart Bell proposed a theory that states that no theory of hidden local variables can ever reproduce all the predictions of quantum mechanics. To date, all such experiments have supported the theory of quantum physics and not the hypothesis of local hidden variables. The 2022 Nobel Prize in Physics was awarded to three scientists (John Clauser, Alain Aspect, and Anton Zeilinger) for their efforts to experimentally validate violations of the Bell inequalities. Bell’s test proves that quantum mechanics is either non-local itself or has non-local hidden variables.</p>]]></content><author><name>Daniel Felps</name><email>dlfelps@gmail.com</email></author><category term="quantum" /><category term="smalltalk" /><summary type="html"><![CDATA[Introduction Our final post in the Quantum Smalltalk series explores a thought experiment proposed by Avshalom Elitzur and Lev Vaidman to demonstrate an unusual quantum feature - interaction-free measurement.]]></summary></entry><entry><title type="html">Experiment 13</title><link href="https://dlfelps.github.io/2024/05/01/quantum-smalltalk4.html" rel="alternate" type="text/html" title="Experiment 13" /><published>2024-05-01T00:00:00+00:00</published><updated>2024-05-01T00:00:00+00:00</updated><id>https://dlfelps.github.io/2024/05/01/quantum-smalltalk4</id><content type="html" xml:base="https://dlfelps.github.io/2024/05/01/quantum-smalltalk4.html"><![CDATA[<h1 id="introduction">Introduction</h1>
<p>In Experiments #10 and #12 we observed photons acting like particles. In Experiment #11 a photon’s actions could only be explained using wave-like behavior. In 1978, John Wheeler proposed an experiment to test the limits this paradox. He designed the experiment to answer the following questions:</p>
<ul>
  <li>Does the photon decide to travel as a wave or a particle depending on the experimental setup?</li>
  <li>And if yes, when does the photon decide?</li>
</ul>

<h1 id="experiment-13">Experiment #13</h1>
<p><img src="/assets/images/exp4.gif" alt="Experiment #13" title="Experiment #13" /></p>

<p>Combine the setups from Experiment #11 and #12 by randomly inserting the second beamsplitter AFTER the photon has interacted with the first beam splitter. This allows the photon to take one of six paths:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">State name</th>
      <th style="text-align: center">Path at BS1</th>
      <th style="text-align: center">BS2 present</th>
      <th style="text-align: center">Path at BS2</th>
      <th style="text-align: center">Detector</th>
      <th style="text-align: center">Probability</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">RX</td>
      <td style="text-align: center">Reflected</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">N/A</td>
      <td style="text-align: center">D1</td>
      <td style="text-align: center">?</td>
    </tr>
    <tr>
      <td style="text-align: center">TX</td>
      <td style="text-align: center">Transmitted</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">N/A</td>
      <td style="text-align: center">D0</td>
      <td style="text-align: center">?</td>
    </tr>
    <tr>
      <td style="text-align: center">RR</td>
      <td style="text-align: center">Reflected</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">Reflected</td>
      <td style="text-align: center">D1</td>
      <td style="text-align: center">?</td>
    </tr>
    <tr>
      <td style="text-align: center">RT</td>
      <td style="text-align: center">Reflected</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">Transmitted</td>
      <td style="text-align: center">D0</td>
      <td style="text-align: center">?</td>
    </tr>
    <tr>
      <td style="text-align: center">TR</td>
      <td style="text-align: center">Transmitted</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">Reflected</td>
      <td style="text-align: center">D0</td>
      <td style="text-align: center">?</td>
    </tr>
    <tr>
      <td style="text-align: center">TT</td>
      <td style="text-align: center">Transmitted</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">Transmitted</td>
      <td style="text-align: center">D1</td>
      <td style="text-align: center">?</td>
    </tr>
  </tbody>
</table>

<p>We have seen both of the setups independently, but now the decision to add the second beamsplitter takes place during the experiment.</p>

<h2 id="results">Results</h2>

<p>Let’s examine two of the Smalltalk simulation runs. In the first example, the second beamsplitter was omitted from the setup.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Emitting a photon from lower path. &gt;&gt; #(0 1)
Photon passing through a beam splitter. &gt;&gt; #(0.4999999999999999 0.4999999999999999)
Second beamsplitter omitted from setup. 
Photon bouncing off of a mirror. &gt;&gt; #(0.4999999999999999 0.4999999999999999)
Photon finally detected with following probabilities: &gt;&gt; #(0.4999999999999999 0.4999999999999999)

</code></pre></div></div>
<p>We observe detection probabilities similar to those in Experiment #12. In the next example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Emitting a photon from lower path. &gt;&gt; #(0 1)
Photon passing through a beam splitter. &gt;&gt; #(0.4999999999999999 0.4999999999999999)
Second beamsplitter inserted into setup after mirror. 
Photon bouncing off of a mirror. &gt;&gt; #(0.4999999999999999 0.4999999999999999)
Photon passing through a beam splitter. &gt;&gt; #(0.9999999999999996 0.0 )
Photon finally detected with following probabilities: &gt;&gt; #(0.9999999999999996 0.0)
</code></pre></div></div>

<p>We observe detection probabilities similar to those in Experiment #11. Filling in the results chart we notice that the table reads as if there were two different experiments going on (i.e. the total observation probability adds up to 2.0!)</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">State name</th>
      <th style="text-align: center">Path at BS1</th>
      <th style="text-align: center">BS2 present</th>
      <th style="text-align: center">Path at BS2</th>
      <th style="text-align: center">Detector</th>
      <th style="text-align: center">Probability</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">RX</td>
      <td style="text-align: center">Reflected</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">N/A</td>
      <td style="text-align: center">D1</td>
      <td style="text-align: center">0.50</td>
    </tr>
    <tr>
      <td style="text-align: center">TX</td>
      <td style="text-align: center">Transmitted</td>
      <td style="text-align: center">No</td>
      <td style="text-align: center">N/A</td>
      <td style="text-align: center">D0</td>
      <td style="text-align: center">0.50</td>
    </tr>
    <tr>
      <td style="text-align: center">RR/TT</td>
      <td style="text-align: center">?</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">?</td>
      <td style="text-align: center">D1</td>
      <td style="text-align: center">0.0</td>
    </tr>
    <tr>
      <td style="text-align: center">RT/TR</td>
      <td style="text-align: center">?</td>
      <td style="text-align: center">Yes</td>
      <td style="text-align: center">?</td>
      <td style="text-align: center">D0</td>
      <td style="text-align: center">1.0</td>
    </tr>
  </tbody>
</table>

<p>This is because there are two experiments happening - as soon as you insert the second beamsplitter you change the experiment.</p>

<h1 id="interpretation">Interpretation</h1>
<p>It is clear that the behavior of the photon in the interferometer depends on the choice of second beamsplitter, even when that choice is made after the photon enters the interferometer. In Wheeler’s words,</p>

<blockquote>
  <p>“we have a strange inversion of the normal order of time. We, now, by moving the mirror in or out have an unavoidable effect on what we have a right to say about the already past history of that photon”</p>
</blockquote>

<p>It may be tempting to interpret this experiment as a case of <a href="https://en.wikipedia.org/wiki/Retrocausality">retrocausality</a>, whereby the insertion of the second beamsplitter causes the photon to retroactively act like a wave instead of a particle. However, this is a leap too far.</p>

<p>Experiment #13, also known as the <a href="https://en.wikipedia.org/wiki/Wheeler%27s_delayed-choice_experiment">delayed-choice experiment</a>, demonstrates a  subtle point of <a href="https://en.wikipedia.org/w/index.php?title=Wave%E2%80%93particle_duality">wave-particle duality</a> - a photon’s behavior is <em>always</em> governed by the Schrödinger equation, yet when measured, it is observed as a particle whose location is determined by the <a href="https://en.wikipedia.org/wiki/Born_rule">Born rule</a>.</p>

<p>This is what is meant by a photon acting like a <em>wave</em> and a <em>particle</em>. But what about Experiments #10 and #12, where the photon acted only like a particle and not like a wave? WRONG. The photon was both, but the wavefunction predicted behavior that did not have any interference (i.e. it is particle-like).</p>

<h1 id="summary">Summary</h1>
<p>Experiment #13 presented John Wheeler’s <a href="https://en.wikipedia.org/wiki/Wheeler%27s_delayed-choice_experiment">delayed-choice experiment</a>. An interesting variation of this experiment is called the <a href="https://en.wikipedia.org/wiki/Delayed-choice_quantum_eraser">delayed-choice quantum eraser</a>.</p>

<h1 id="appendix-the-smalltalk-code">Appendix: The Smalltalk code</h1>
<p>The full Pharo package can be found at <a href="https://github.com/dlfelps/MZI">dlfeps/MZI</a>.</p>]]></content><author><name>Daniel Felps</name><email>dlfelps@gmail.com</email></author><category term="quantum" /><category term="smalltalk" /><summary type="html"><![CDATA[Introduction In Experiments #10 and #12 we observed photons acting like particles. In Experiment #11 a photon’s actions could only be explained using wave-like behavior. In 1978, John Wheeler proposed an experiment to test the limits this paradox. He designed the experiment to answer the following questions: Does the photon decide to travel as a wave or a particle depending on the experimental setup? And if yes, when does the photon decide?]]></summary></entry><entry><title type="html">Experiment 12</title><link href="https://dlfelps.github.io/2024/04/01/quantum-smalltalk3.html" rel="alternate" type="text/html" title="Experiment 12" /><published>2024-04-01T00:00:00+00:00</published><updated>2024-04-01T00:00:00+00:00</updated><id>https://dlfelps.github.io/2024/04/01/quantum-smalltalk3</id><content type="html" xml:base="https://dlfelps.github.io/2024/04/01/quantum-smalltalk3.html"><![CDATA[<h1 id="introduction">Introduction</h1>
<p>Experiment #12 doesn’t introduce any new concepts, but it prepares us for a surprising result in Experiment #13.</p>

<h1 id="experiment-12">Experiment #12</h1>
<p><img src="/assets/images/exp3.png" alt="Experiment #12" title="Experiment #12" /></p>

<p>Modify the setup from Experiment #11 by removing the second beamsplitter. This allows the photon to take one of two paths:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">State name</th>
      <th style="text-align: center">Path at BS1</th>
      <th style="text-align: center">Detector</th>
      <th style="text-align: center">Probability</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">R</td>
      <td style="text-align: center">Reflected</td>
      <td style="text-align: center">D0</td>
      <td style="text-align: center">?</td>
    </tr>
    <tr>
      <td style="text-align: center">T</td>
      <td style="text-align: center">Transmitted</td>
      <td style="text-align: center">D1</td>
      <td style="text-align: center">?</td>
    </tr>
  </tbody>
</table>

<p>We don’t yet know the outcome of the experiment, but based on our observations from Experiment 10 we might expect an equal distribution between D0 and D1. Let’s run the Smalltalk simulation.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Emitting a photon from lower path. &gt;&gt; #(0 1)
Photon passing through a beam splitter. &gt;&gt; #(0.4999999999999999 0.4999999999999999)
Photon bouncing off of a mirror. &gt;&gt; #(0.4999999999999999 0.4999999999999999)
Photon finally detected with following probabilities: &gt;&gt; #(0.4999999999999999 0.4999999999999999)
</code></pre></div></div>

<p>Our intuition was correct! After the first beamsplitter the photon is equally likely to be on the upper and lower path, but this time the paths are not recombined using the second beamsplitter. So any photons that are reflected at BS1 end up at D0 and any photons that are transmitted at BS1 end up at D1. We always know which path the photon took.</p>

<h2 id="the-wavefunction">The wavefunction</h2>

<p>How does this affect the photon’s wavefunction? Initially, after interacting with the beamsplitter we do not know which path the photon is on. Therefore its wavefunction is a superposition of states of the upper and lower paths.  At the moment just before the photon would reach D0 or D1, its wavefunction predicts with 50% probability that the photon will be detected at D0 and 50% probability that the photon will be detected at D1. An instant later it is detected at either D0 or D1. But how does the wavefunction predict two equally likely locations in one instant and then the next instant, the probabilities are gone and the photon is detected at D0 or D1?</p>

<h2 id="measurement-of-a-quantum-system">Measurement of a quantum system</h2>

<p>When scientists say they are taking a “measurement” they are describing the action or process of observing something in order to gain information. But in quantum mechanics, the term “measurement” has both practical and philosophical implications. From a practical point of view, measuring a quantum system changes the quantum state that describes that system; this is sometimes described as causing the wavefunction to collapse (i.e. it is no longer in a superposition of states). From a philosophical point of view, how did the system know it was being measured? In other words, what caused the collapse? How are the probabilities converted into an actual, well-defined classical outcome? The answer to these questions depends on your interpretation of quantum mechanics and is beyond the scope of this post. For those interested, I thoroughly enjoyed listening to this <a href="https://youtu.be/GdqC2bVLesQ?si=yhlTgSpCbw2Gfv74">panel discussion</a> on the topic.</p>

<h1 id="summary">Summary</h1>
<p>Experiment 12 explored the measurement problem - the instant that the photon becomes a particle (as described by the wavefunction). The next experiment challenges our everyday understanding of reality.</p>

<h1 id="appendix-the-smalltalk-code">Appendix: The Smalltalk code</h1>
<p>The full Pharo package can be found at <a href="https://github.com/dlfelps/MZI">dlfeps/MZI</a>.</p>]]></content><author><name>Daniel Felps</name><email>dlfelps@gmail.com</email></author><category term="quantum" /><category term="smalltalk" /><summary type="html"><![CDATA[Introduction Experiment #12 doesn’t introduce any new concepts, but it prepares us for a surprising result in Experiment #13.]]></summary></entry><entry><title type="html">Experiment 11</title><link href="https://dlfelps.github.io/2024/03/01/quantum-smalltalk2.html" rel="alternate" type="text/html" title="Experiment 11" /><published>2024-03-01T00:00:00+00:00</published><updated>2024-03-01T00:00:00+00:00</updated><id>https://dlfelps.github.io/2024/03/01/quantum-smalltalk2</id><content type="html" xml:base="https://dlfelps.github.io/2024/03/01/quantum-smalltalk2.html"><![CDATA[<h1 id="introduction">Introduction</h1>
<p>Experiment 11 introduces the concepts of quantum superposition by making a slight modification to Experiment 10.</p>

<h1 id="experiment-11">Experiment #11</h1>
<p><img src="/assets/images/exp2.PNG" alt="Experiment #11" title="Experiment #11" /></p>

<p>Modify the setup from Experiment #10 by removing the block on the lower path. This allows the photon to now take one of four paths:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">State name</th>
      <th style="text-align: center">Path at BS1</th>
      <th style="text-align: center">Path at BS2</th>
      <th style="text-align: center">Detector</th>
      <th style="text-align: center">Probability</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">RR</td>
      <td style="text-align: center">Reflected</td>
      <td style="text-align: center">Reflected</td>
      <td style="text-align: center">D1</td>
      <td style="text-align: center">?</td>
    </tr>
    <tr>
      <td style="text-align: center">RT</td>
      <td style="text-align: center">Reflected</td>
      <td style="text-align: center">Transmitted</td>
      <td style="text-align: center">D0</td>
      <td style="text-align: center">?</td>
    </tr>
    <tr>
      <td style="text-align: center">TR</td>
      <td style="text-align: center">Transmitted</td>
      <td style="text-align: center">Reflected</td>
      <td style="text-align: center">D0</td>
      <td style="text-align: center">?</td>
    </tr>
    <tr>
      <td style="text-align: center">TT</td>
      <td style="text-align: center">Transmitted</td>
      <td style="text-align: center">Transmitted</td>
      <td style="text-align: center">D1</td>
      <td style="text-align: center">?</td>
    </tr>
  </tbody>
</table>

<p>We don’t yet know the outcome of the experiment, but based on our observations from Experiment 10 we might expect an equal distribution between D0 and D1. However, that is not what we observe. Let’s run the Smalltalk simulation.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Emitting a photon from lower path. &gt;&gt; #(0 1)
Photon passing through a beam splitter. &gt;&gt; #(0.4999999999999999 0.4999999999999999)
Photon bouncing off of a mirror. &gt;&gt; #(0.4999999999999999 0.4999999999999999)
Photon passing through a beam splitter. &gt;&gt; #(0.9999999999999996 0.0)
Photon finally detected with following probabilities: &gt;&gt; #(0.9999999999999996 0.0)
</code></pre></div></div>

<p>After the first beamsplitter the photon is equally likely to be on the upper and lower path (i.e. 50/50) - the same as in Experiment 10. But this time the lower path is not blocked and the second beam splitter sends all of the photons to D0. How is this possible?</p>

<h2 id="what-is-superposition">WHAT is Superposition</h2>

<p>Quantum mechanics explains this phenomenon by saying that the wavefunction of the photon was in a superposition of two states (i.e. one state going through the upper path and one state going through the lower path). NOTE: this is different that saying that it went through both paths or neither path.</p>

<p>The experiment was designed in such a way that the wavefunction for state RR lags behind state TT by half a wavelength, resulting in destructive interference. The probability amplitude goes to zero and there are no photons at D1. States described by RT and TR arrive with their waves in sync, resulting in constructive interference. The probability amplitude doubles and all the light reaches D0.</p>

<p>The photon itself doesn’t split because it can’t. The wavefunction of the photon captures the fact that the photon could be in two equally likely states (lower path and upper path). Then using this wavefunction you can calculate the probability that the photon is detected at D0 and D1 and you get:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Photon outcome</th>
      <th style="text-align: center">probability</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Detected at D0</td>
      <td style="text-align: center">1.0</td>
    </tr>
    <tr>
      <td style="text-align: center">Detected at D1</td>
      <td style="text-align: center">0</td>
    </tr>
  </tbody>
</table>

<p>But importantly, we cannot say whether the photon was in state TR (upper path) or RT (lower path) only that it was detected at D0. This is an example of particle-wave duality - the photon’s wavefunction acts like a wave (destructive and constructive interference), but is ultimately measured as a single photon.</p>

<h2 id="why-is-superposition">WHY is Superposition</h2>

<p>No one knows for sure and those that think they do can’t agree.</p>

<h2 id="when-is-superposition">WHEN is Superposition</h2>

<p>Although we don’t know why it happens, we can describe the conditions when we observe it. In this case, it happened because the observers (e.g. you, me, or the universe) couldn’t tell which path the photon took. Each path was sufficiently ambiguous to allow the photon’s wavefunction to remain in superposition. In Experiment 10, when we blocked the lower path, the photon couldn’t be in superposition because we knew it must have taken the upper path to arrive at the detectors.</p>

<h1 id="summary">Summary</h1>
<p>Experiment 11 explored the wave-like nature of a photon demonstrated by the destructive interference that occurs between the two superposition states of the system. The next experiment explores what happens when we remove the second beam splitter.</p>

<h1 id="appendix-the-smalltalk-code">Appendix: The Smalltalk code</h1>
<p>The full Pharo package can be found at <a href="https://github.com/dlfelps/MZI">dlfeps/MZI</a>.</p>]]></content><author><name>Daniel Felps</name><email>dlfelps@gmail.com</email></author><category term="quantum" /><category term="smalltalk" /><summary type="html"><![CDATA[Introduction Experiment 11 introduces the concepts of quantum superposition by making a slight modification to Experiment 10.]]></summary></entry><entry><title type="html">Experiment 10</title><link href="https://dlfelps.github.io/2024/02/01/quantum-smalltalk1.html" rel="alternate" type="text/html" title="Experiment 10" /><published>2024-02-01T00:00:00+00:00</published><updated>2024-02-01T00:00:00+00:00</updated><id>https://dlfelps.github.io/2024/02/01/quantum-smalltalk1</id><content type="html" xml:base="https://dlfelps.github.io/2024/02/01/quantum-smalltalk1.html"><![CDATA[<h1 id="introducing-the-quantum-smalltalk-series">Introducing the Quantum Smalltalk series</h1>
<p>In this series I am going to introduce you to some of my favorite quantum experiments while modeling those experiments in <a href="https://pharo.org/">Pharo Smalltalk</a>. We will explore the quantum properties of superposition and entanglement. Our experimental model is rather simple - the optical devices typically used in such experiments (i.e. beam splitters, polarizers, mirrors) will be modeled using complex-valued linear transformations. Although the results of matrix multiplication may not surprise you, I hope that the results of these experiments will. I could have called this the “Complex-valued matrix multiplication with Smalltalk series,” but that doesn’t have quite the same ring.</p>

<h2 id="why-smalltalk">Why Smalltalk?</h2>
<p>I chose Smalltalk for this series because it allows me to quickly implement an internal (or embedded) domain specific language (DSL) to describe the quantum experiments. You will become more familiar with the DSL as we progress, but here is a sample:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Photon new
	beamSplitter;
	blockLowerPath;
	mirror;
	beamSplitter;
	detector.
</code></pre></div></div>
<p>A good DSL simplifies the code to allow you to focus on the concepts rather than the syntax. A great DSL is self-explanatory, allowing a domain expert (in this case a physicist) to use it without any previous programming experience. I don’t know any physicists so this is at least a good DSL.</p>

<h2 id="the-mach-zehnder-setup">The Mach-Zehnder setup</h2>
<p>All of the experiments in this series will be variations of the <a href="https://en.wikipedia.org/wiki/Mach%E2%80%93Zehnder_interferometer">Mach-Zehnder interferometer</a>. It was originally proposed in 1891 to measure phase shifts between the two paths caused by a sample, but it has since been adapted to study a variety of quantum effects. Why aren’t we using the double-slit experiment? It may be the most iconic quantum experiment, but it is also difficult to model because it requires differential equations. We can demonstrate multiple quantum properties (i.e. superposition and entanglement) using the much simpler Mach-Zehnder setup.</p>

<blockquote>
  <p>Feynman once claimed that any question in quantum mechanics could be answered using the double-slit experiment. (But of course he said it as only he could, “You remember the experiment with the two holes? It’s the same thing.”)</p>
</blockquote>

<p>The purpose of the first experiment is to familiarize yourself with the:</p>
<ul>
  <li>experimental setup and optical components used</li>
  <li>modeling approach (i.e. matrix multiplication)</li>
  <li>Smalltalk DSL describing the experimental setup</li>
</ul>

<h3 id="basic-optical-components">Basic optical components</h3>
<p>This section describes the optical components used in the first 2 experiments. Each component is described in common language as well as its equivalent mathematical  transformation. Credit: All of the diagrams and mathematical notation used in this series follows from <a href="https://ocw.mit.edu/courses/8-04-quantum-physics-i-spring-2016">MIT’s Quantum Physics 1</a>; this is an excellent course taught by Dr. Barton Zwiebach.</p>

<h3 id="photon-emitter">Photon Emitter</h3>
<p>Luckily for us, all of the components have rather descriptive names. In this experiment, we will not be using a coherent laser as the source, but instead a single photon will traverse the optical path (or paths) of the experiment. When a photon is emitted on the upper beam it is represented by the following probability amplitudes:</p>

<math xmlns="http://www.w3.org/1998/Math/MathML" data-latex="lower_{path}=\begin{bmatrix}0\\1\end{bmatrix}, upper_{path}=\begin{bmatrix}1\\0\end{bmatrix}" display="block">
  <mrow>
    <mrow>
      <mi data-latex="l">l</mi>
      <mo>&#x2062;</mo>
      <mi data-latex="o">o</mi>
      <mo>&#x2062;</mo>
      <mi data-latex="w">w</mi>
      <mo>&#x2062;</mo>
      <mi data-latex="e">e</mi>
      <mo>&#x2062;</mo>
      <msub data-latex="r_{p a t h}">
        <mi data-latex="r">r</mi>
        <mrow data-mjx-texclass="ORD" data-latex="{p a t h}">
          <mi data-latex="p">p</mi>
          <mo>&#x2062;</mo>
          <mi data-latex="a">a</mi>
          <mo>&#x2062;</mo>
          <mi data-latex="t">t</mi>
          <mo>&#x2062;</mo>
          <mi data-latex="h">h</mi>
        </mrow>
      </msub>
    </mrow>
    <mo data-latex="=">=</mo>
    <mrow data-mjx-texclass="INNER" data-latex-item="{bmatrix}" data-latex="{bmatrix}">
      <mo data-mjx-texclass="OPEN">[</mo>
      <mtable columnspacing="1em" rowspacing="4pt">
        <mtr>
          <mtd>
            <mn data-latex="0">0</mn>
          </mtd>
        </mtr>
        <mtr>
          <mtd>
            <mn data-latex="1">1</mn>
          </mtd>
        </mtr>
      </mtable>
      <mo data-mjx-texclass="CLOSE">]</mo>
    </mrow>
  </mrow>
  <mo data-latex=",">,</mo>
  <mrow>
    <mrow>
      <mi data-latex="u">u</mi>
      <mo>&#x2062;</mo>
      <mi data-latex="p">p</mi>
      <mo>&#x2062;</mo>
      <mi data-latex="p">p</mi>
      <mo>&#x2062;</mo>
      <mi data-latex="e">e</mi>
      <mo>&#x2062;</mo>
      <msub data-latex="r_{p a t h}">
        <mi data-latex="r">r</mi>
        <mrow data-mjx-texclass="ORD" data-latex="{p a t h}">
          <mi data-latex="p">p</mi>
          <mo>&#x2062;</mo>
          <mi data-latex="a">a</mi>
          <mo>&#x2062;</mo>
          <mi data-latex="t">t</mi>
          <mo>&#x2062;</mo>
          <mi data-latex="h">h</mi>
        </mrow>
      </msub>
    </mrow>
    <mo data-latex="=">=</mo>
    <mrow data-mjx-texclass="INNER" data-latex-item="{bmatrix}" data-latex="{bmatrix}">
      <mo data-mjx-texclass="OPEN">[</mo>
      <mtable columnspacing="1em" rowspacing="4pt">
        <mtr>
          <mtd>
            <mn data-latex="1">1</mn>
          </mtd>
        </mtr>
        <mtr>
          <mtd>
            <mn data-latex="0">0</mn>
          </mtd>
        </mtr>
      </mtable>
      <mo data-mjx-texclass="CLOSE">]</mo>
    </mrow>
  </mrow>
</math>

<h3 id="beamsplitter">Beamsplitter</h3>
<p><img src="/assets/images/beamSplitter.PNG" alt="Beamsplitter" title="Beamsplitter" /></p>

<p>If you shine a laser at a balanced beam splitter (the only kind we model here) then exactly 50% of the light is transmitted and the remaining 50% is reflected (also undergoing a phase shift of PI). What happens if you send a single photon instead of a laser? Hopefully you will be able to answer that after the second experiment, but for now assume that there is a 50% chance that it gets reflected and a 50% chance that it gets transmitted. This is represented mathematically by:</p>

<math xmlns="http://www.w3.org/1998/Math/MathML" data-latex="\frac{1}{\sqrt{2}}\begin{bmatrix}1 &amp; i\\i &amp; 1\end{bmatrix}" display="block">
  <mfrac data-latex="\frac{1}{\sqrt{2}}">
    <mn data-latex="1">1</mn>
    <msqrt data-latex="\sqrt{2}">
      <mn data-latex="2">2</mn>
    </msqrt>
  </mfrac>
  <mo>&#x2062;</mo>
  <mrow data-mjx-texclass="INNER" data-latex-item="{bmatrix}" data-latex="{bmatrix}">
    <mo data-mjx-texclass="OPEN">[</mo>
    <mtable columnspacing="1em" rowspacing="4pt">
      <mtr>
        <mtd>
          <mn data-latex="1">1</mn>
        </mtd>
        <mtd>
          <mi data-latex="i">i</mi>
        </mtd>
      </mtr>
      <mtr>
        <mtd>
          <mi data-latex="i">i</mi>
        </mtd>
        <mtd>
          <mn data-latex="1">1</mn>
        </mtd>
      </mtr>
    </mtable>
    <mo data-mjx-texclass="CLOSE">]</mo>
  </mrow>
</math>

<blockquote>
  <h3 id="an-aside-on-probabilities">An aside on probabilities</h3>
  <p>The careful reader will notice that the result of a photon passing through a beamsplitter yields 1/sqrt(2) instead of 1/2. That is because this number represents a <strong>probability amplitude</strong>.</p>
</blockquote>

<math xmlns="http://www.w3.org/1998/Math/MathML" data-latex="\frac{1}{\sqrt{2}}\begin{bmatrix}1 &amp; i\\i &amp; 1\end{bmatrix}\begin{bmatrix}0\\1\end{bmatrix}=\begin{bmatrix}0+\sqrt{2}i\\\sqrt{2}+0i\end{bmatrix}" display="block">
  <mrow>
    <mfrac data-latex="\frac{1}{\sqrt{2}}">
      <mn data-latex="1">1</mn>
      <msqrt data-latex="\sqrt{2}">
        <mn data-latex="2">2</mn>
      </msqrt>
    </mfrac>
    <mo>&#x2062;</mo>
    <mrow data-mjx-texclass="INNER" data-latex-item="{bmatrix}" data-latex="{bmatrix}">
      <mo data-mjx-texclass="OPEN">[</mo>
      <mtable columnspacing="1em" rowspacing="4pt">
        <mtr>
          <mtd>
            <mn data-latex="1">1</mn>
          </mtd>
          <mtd>
            <mi data-latex="i">i</mi>
          </mtd>
        </mtr>
        <mtr>
          <mtd>
            <mi data-latex="i">i</mi>
          </mtd>
          <mtd>
            <mn data-latex="1">1</mn>
          </mtd>
        </mtr>
      </mtable>
      <mo data-mjx-texclass="CLOSE">]</mo>
    </mrow>
    <mo>&#x2062;</mo>
    <mrow data-mjx-texclass="INNER" data-latex-item="{bmatrix}" data-latex="{bmatrix}">
      <mo data-mjx-texclass="OPEN">[</mo>
      <mtable columnspacing="1em" rowspacing="4pt">
        <mtr>
          <mtd>
            <mn data-latex="0">0</mn>
          </mtd>
        </mtr>
        <mtr>
          <mtd>
            <mn data-latex="1">1</mn>
          </mtd>
        </mtr>
      </mtable>
      <mo data-mjx-texclass="CLOSE">]</mo>
    </mrow>
  </mrow>
  <mo data-latex="=">=</mo>
  <mrow data-mjx-texclass="INNER" data-latex-item="{bmatrix}" data-latex="{bmatrix}">
    <mo data-mjx-texclass="OPEN">[</mo>
    <mtable columnspacing="1em" rowspacing="4pt">
      <mtr>
        <mtd>
          <mrow>
            <mn data-latex="0">0</mn>
            <mo data-latex="+">+</mo>
            <mrow>
              <msqrt data-latex="\sqrt{2}">
                <mn data-latex="2">2</mn>
              </msqrt>
              <mo>&#x2062;</mo>
              <mi data-latex="i">i</mi>
            </mrow>
          </mrow>
        </mtd>
      </mtr>
      <mtr>
        <mtd>
          <mrow>
            <msqrt data-latex="\sqrt{2}">
              <mn data-latex="2">2</mn>
            </msqrt>
            <mo data-latex="+">+</mo>
            <mrow>
              <mn data-latex="0">0</mn>
              <mo>&#x2062;</mo>
              <mi data-latex="i">i</mi>
            </mrow>
          </mrow>
        </mtd>
      </mtr>
    </mtable>
    <mo data-mjx-texclass="CLOSE">]</mo>
  </mrow>
</math>

<blockquote>
  <p>You can convert a probability amplitude to a probability by taking its magnitude and squaring it.</p>
</blockquote>

<math xmlns="http://www.w3.org/1998/Math/MathML" data-latex="\lvert0+\sqrt{2}i\rvert^2=0.5" display="block">
  <msup data-latex="\rvert^2">
    <mrow>
      <mo data-mjx-texclass="OPEN" fence="false" stretchy="false" data-latex="\lvert">|</mo>
      <mrow>
        <mn data-latex="0">0</mn>
        <mo data-latex="+">+</mo>
        <mrow>
          <msqrt data-latex="\sqrt{2}">
            <mn data-latex="2">2</mn>
          </msqrt>
          <mo>&#x2062;</mo>
          <mi data-latex="i">i</mi>
        </mrow>
      </mrow>
      <mo data-mjx-texclass="CLOSE" fence="false" stretchy="false" data-latex="\rvert">|</mo>
    </mrow>
    <mn data-latex="2">2</mn>
  </msup>
  <mo data-latex="=">=</mo>
  <mn data-latex=".5">0.5</mn>
</math>

<h3 id="mirror">Mirror</h3>
<p><img src="/assets/images/mirror.PNG" alt="Mirror" title="Mirror" /></p>

<p>A mirror reflects an incoming photon while undergoing a phase shift of <em>pi</em>.</p>

<math xmlns="http://www.w3.org/1998/Math/MathML" data-latex="\begin{bmatrix}0 &amp; 1\\1 &amp; 0\end{bmatrix}" display="block">
  <mrow data-mjx-texclass="INNER" data-latex-item="{bmatrix}" data-latex="\begin{bmatrix}0 &amp; 1\\1 &amp; 0\end{bmatrix}">
    <mo data-mjx-texclass="OPEN">[</mo>
    <mtable columnspacing="1em" rowspacing="4pt">
      <mtr>
        <mtd>
          <mn data-latex="0">0</mn>
        </mtd>
        <mtd>
          <mn data-latex="1">1</mn>
        </mtd>
      </mtr>
      <mtr>
        <mtd>
          <mn data-latex="1">1</mn>
        </mtd>
        <mtd>
          <mn data-latex="0">0</mn>
        </mtd>
      </mtr>
    </mtable>
    <mo data-mjx-texclass="CLOSE">]</mo>
  </mrow>
</math>

<h3 id="block">Block</h3>

<p><img src="/assets/images/blockLower.PNG" alt="Block" title="Block" /></p>

<p>A block absorbs an incoming photon, preventing it from reaching any downstream components. In the diagram above, the beamsplitter produces a 50% chance that the photon is absorbed by the block and a 50% chance that the photon is allowed to continue on the upper path.</p>

<math xmlns="http://www.w3.org/1998/Math/MathML" data-latex="block_{lower}=\begin{bmatrix}1 &amp; 0\\0 &amp; 0\end{bmatrix}" display="block">
  <mrow>
    <mi data-latex="b">b</mi>
    <mo>&#x2062;</mo>
    <mi data-latex="l">l</mi>
    <mo>&#x2062;</mo>
    <mi data-latex="o">o</mi>
    <mo>&#x2062;</mo>
    <mi data-latex="c">c</mi>
    <mo>&#x2062;</mo>
    <msub data-latex="k_{l o w e r}">
      <mi data-latex="k">k</mi>
      <mrow data-mjx-texclass="ORD" data-latex="{l o w e r}">
        <mi data-latex="l">l</mi>
        <mo>&#x2062;</mo>
        <mi data-latex="o">o</mi>
        <mo>&#x2062;</mo>
        <mi data-latex="w">w</mi>
        <mo>&#x2062;</mo>
        <mi data-latex="e">e</mi>
        <mo>&#x2062;</mo>
        <mi data-latex="r">r</mi>
      </mrow>
    </msub>
  </mrow>
  <mo data-latex="=">=</mo>
  <mrow data-mjx-texclass="INNER" data-latex-item="{bmatrix}" data-latex="{bmatrix}">
    <mo data-mjx-texclass="OPEN">[</mo>
    <mtable columnspacing="1em" rowspacing="4pt">
      <mtr>
        <mtd>
          <mn data-latex="1">1</mn>
        </mtd>
        <mtd>
          <mn data-latex="0">0</mn>
        </mtd>
      </mtr>
      <mtr>
        <mtd>
          <mn data-latex="0">0</mn>
        </mtd>
        <mtd>
          <mn data-latex="0">0</mn>
        </mtd>
      </mtr>
    </mtable>
    <mo data-mjx-texclass="CLOSE">]</mo>
  </mrow>
</math>

<h3 id="photon-detector">Photon Detector</h3>
<p>This component detects a single photon. Most of the experimental setups used in this series will involve 2 detectors: D0 measuring the upper path and D1 measuring the lower path. Just as the emitter emits a real photon, the detector detects a real photon (i.e. it does not measure probability amplitudes or probabilities). The mathematical equivalent of the photon detector would be to sample the probabilities of all possible end-states of the photon (they should add up to 1). We will forgo this step and instead just report the associated probabilities.</p>

<h2 id="experiment-10">Experiment #10</h2>

<p><img src="/assets/images/exp1.PNG" alt="Experiment #10" title="Experiment #10" /></p>

<p>This experiment is relatively straightforward - its result is intuitive and agrees with a more classical interpretation. The setup includes:</p>
<ul>
  <li>1 photon emitter</li>
  <li>1 block</li>
  <li>2 beam-splitters</li>
  <li>2 mirrors</li>
  <li>2 detectors</li>
</ul>

<p>Before we do the math, let’s guess what might happen if we run this experiment 100 times. If the beamsplitters act like a random coin (heads the photon transmits, tails it reflects) then one might expect the following outcome:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Photon outcome</th>
      <th style="text-align: center">counts</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Detected at D0</td>
      <td style="text-align: center">25</td>
    </tr>
    <tr>
      <td style="text-align: center">Detected at D1</td>
      <td style="text-align: center">25</td>
    </tr>
    <tr>
      <td style="text-align: center">Absorbed by block</td>
      <td style="text-align: center">50</td>
    </tr>
  </tbody>
</table>

<p>Next let’s run the experiment and see if the calculated probabilities agree with our intuition (I’ll defer the Smalltalk code for now and just show the output report).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Emitting a photon from lower path. &gt;&gt; #(0 1)
Photon passing through a beam splitter. &gt;&gt; #(0.4999999999999999 0.4999999999999999)
Photon's path blocked on lower path. &gt;&gt; #(0.4999999999999999 0)
Photon bouncing off of a mirror. &gt;&gt; #(0.0 0.4999999999999999)
Photon passing through a beam splitter. &gt;&gt; #(0.2499999999999999 0.2499999999999999)
Photon finally detected with following probabilities: &gt;&gt; #(0.2499999999999999 0.2499999999999999)
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Photon outcome</th>
      <th style="text-align: center">probability</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Detected at D0</td>
      <td style="text-align: center">0.25</td>
    </tr>
    <tr>
      <td style="text-align: center">Detected at D1</td>
      <td style="text-align: center">0.25</td>
    </tr>
    <tr>
      <td style="text-align: center">Absorbed by block</td>
      <td style="text-align: center">0.50</td>
    </tr>
  </tbody>
</table>

<p>The computed probabilities agree with our intuition!</p>

<h2 id="summary">Summary</h2>
<p>Experiment 10 laid the groundwork for the quantum properties we want to explore in the rest of the series. It introduced  the optical components and how they are modeled mathematically. However, I have not yet shown the Smalltalk code because it is not as important as the rest. If you want to better understand how to compute the probability amplitudes at an arbitrary point in the path then I would encourage you to consider watching the first few lectures of <a href="https://ocw.mit.edu/courses/8-04-quantum-physics-i-spring-2016">MIT’s Quantum Physics 1</a>.</p>

<h2 id="appendix-the-smalltalk-code">Appendix: The Smalltalk code</h2>
<p>I was surprised at how simple the Smalltalk DSL code turned out to be. It’s almost anti-climactic at this point, but the code almost line-by-line describes the order of the components in the experiment. Please keep in mind that the mathematical complexity lies beneath this layer and is hidden from the user. The full Pharo package can be found at <a href="https://github.com/dlfelps/MZI">dlfeps/MZI</a>.</p>

<p><img src="/assets/images/exp1-annotated.PNG" alt="Experiment #1" title="Experiment #1" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 Photon new
2   beamSplitter;
3   blockLowerPath;
4   mirror;
5   beamSplitter;
6   detector.
</code></pre></div></div>]]></content><author><name>Daniel Felps</name><email>dlfelps@gmail.com</email></author><category term="quantum" /><category term="smalltalk" /><summary type="html"><![CDATA[Introducing the Quantum Smalltalk series In this series I am going to introduce you to some of my favorite quantum experiments while modeling those experiments in Pharo Smalltalk. We will explore the quantum properties of superposition and entanglement. Our experimental model is rather simple - the optical devices typically used in such experiments (i.e. beam splitters, polarizers, mirrors) will be modeled using complex-valued linear transformations. Although the results of matrix multiplication may not surprise you, I hope that the results of these experiments will. I could have called this the “Complex-valued matrix multiplication with Smalltalk series,” but that doesn’t have quite the same ring.]]></summary></entry><entry><title type="html">Experiment 09</title><link href="https://dlfelps.github.io/2022/11/01/inclusive.html" rel="alternate" type="text/html" title="Experiment 09" /><published>2022-11-01T00:00:00+00:00</published><updated>2022-11-01T00:00:00+00:00</updated><id>https://dlfelps.github.io/2022/11/01/inclusive</id><content type="html" xml:base="https://dlfelps.github.io/2022/11/01/inclusive.html"><![CDATA[<p>This post explores the possibility of using <em>inclusive</em> programming languages, i.e. ones that successfully accommodate functional and object-oriented programming styles in a single codebase.</p>

<h2 id="introduction">Introduction</h2>

<p>Python, C++, Java, and C# are 4 out of the top 10 most popular languages on any survey/poll/list, and they have one thing in common - they are all primarily object-oriented languages. This paradigm is characterized by<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>:</p>

<ul>
  <li>Data/operations are encapsulated in objects</li>
  <li>Information hiding is used to protect internal properties of an object</li>
  <li>Objects interact by means of message passing</li>
  <li>Classes are organized in inheritance hierarchies</li>
</ul>

<p>But even these classic languages are now including new features to support a more functional programming style; some people see this as a sign of an upcoming paradigm shift<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>. My thoughts are more in line with Richard Feldman who argued in his talk <a href="https://youtu.be/QyJZzq0v7Z4?t=2319">“Why isn’t functional programming the norm?”</a> that we are currently undergoing an intermediate phase where we are starting to apply functional programming techniques within object-oriented languages. This post uses 5 criteria to find suitable languages to be used for this purpose.</p>

<h2 id="inclusive-programming-criteria">Inclusive programming criteria</h2>

<p>The ideal inclusive language is one that allows each individual within a team to follow their preferred programming style (i.e. object-oriented or functional). Alas, no such language exists. We next examine the critical elements necessary to provide successful collaboration between these unique programming styles. These elements are used to <strong>support</strong> and <strong>identify</strong> each paradigm.</p>

<blockquote>
  <p>This concept is distinct from that of <a href="https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Multiparadigm_languages">multiparadigm languages</a>. The primary difference being that while multiparadigm languages might support more than one paradigm, they may not necessarily be well-suited to support more than one paradigm within a single codebase.</p>
</blockquote>

<h3 id="criteria-to-support-an-object-oriented-paradigm">Criteria to support an object-oriented paradigm</h3>

<p>I identify 3 properties that are essential for any object-oriented programmer to feel at home in a language:</p>

<blockquote>
  <p>O1. classes with methods and properties</p>

  <p>O2. encapsulation (i.e. the ability to hide data/methods)</p>

  <p>O3. subtype polymorphism (subtyping)</p>
</blockquote>

<p>Encapsulation and subtyping<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup> are necessary to apply common design patterns; they also allow programmers to adhere to guiding principles that are well-known within their community. For example, subtyping enables both the “O” and “L” in <a href="https://stackify.com/solid-design-principles/">S<strong>OL</strong>ID design principles</a>.</p>

<p>This relatively minimal subset of language features doesn’t narrow our options much yet; let’s discuss the elements critical to functional programming.</p>

<h3 id="criteria-to-support-a-functional-paradigm">Criteria to support a functional paradigm</h3>

<p>The two most defining features of the functional programming style are pure functions<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup> <sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>and immutable data. But these strategies do not require any special language features. One criteria that is often needed to support functional programming is that functions are treated as first-class citizens<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup>.</p>

<blockquote>
  <p>F1. functions are first-class</p>
</blockquote>

<p>Most modern languages treat functions as first-class citizens.</p>

<h3 id="criteria-to-identify-each-paradigm">Criteria to identify each paradigm</h3>

<p>To properly meet our definition of <em>inclusive</em> we must also be able to identify which programming paradigm a particular piece of code follows.</p>

<p>How do you identify object-oriented code? This paradigm is full of easy to spot code smells:</p>
<ul>
  <li>classes</li>
  <li><code class="language-plaintext highlighter-rouge">for</code> loops</li>
  <li>mutable variables</li>
</ul>

<p>How do you identify functional code? At a glance it may be difficult to pin down functional code, but here are a few things to look for:</p>
<ul>
  <li>no classes</li>
  <li>no <code class="language-plaintext highlighter-rouge">for</code> loops</li>
  <li>no mutable variables</li>
  <li>lots of functions</li>
</ul>

<p>Classes and <code class="language-plaintext highlighter-rouge">for</code> loops are easy enough to spot, but what about mutable variables? In order to facilitate this distinction, we add the following criteria:</p>

<blockquote>
  <p>C1. mutable variables must be designated as such</p>
</blockquote>

<p>This final criteria drastically narrows down the field. The remaining<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup> contenders that make our list of inclusive languages are: Kotlin, Scala, Rust, Swift. Let’s briefly examine how each language meets the criteria.</p>

<h2 id="inclusive-languages">Inclusive languages</h2>

<p>This section is included to show how each of the languages meet the inclusive criteria. You may choose to skip it.</p>

<h3 id="kotlin">Kotlin</h3>

<blockquote>
  <p><a href="https://kotlinlang.org/">Kotlin</a> is a “modern programming language that makes developers happier.”</p>
</blockquote>

<ul>
  <li>O1 - has regular classes (plus enums, data classes, and sealed classes)</li>
  <li>O2 - class properties/methods can be made <code class="language-plaintext highlighter-rouge">private</code></li>
  <li>O3 - uses interfaces for creating subtypes</li>
  <li>F1 - functions are first-class (also supports anonymous functions)</li>
  <li>C1 - immutable variables are initialized with <code class="language-plaintext highlighter-rouge">val</code>; mutable variables are initialized with <code class="language-plaintext highlighter-rouge">var</code></li>
</ul>

<h3 id="scala">Scala</h3>

<blockquote>
  <p>“<a href="https://www.scala-lang.org/">Scala</a> combines object-oriented and functional programming in one concise, high-level language.”</p>
</blockquote>

<ul>
  <li>O1 - has regular classes (plus enums and case classes)</li>
  <li>O2 - class properties/methods can be made <code class="language-plaintext highlighter-rouge">private</code></li>
  <li>O3 - uses interfaces for creating subtypes (with mixin composition to compose components)</li>
  <li>F1 - functions are first-class (also supports anonymous functions)</li>
  <li>C1 - immutable variables are initialized with <code class="language-plaintext highlighter-rouge">val</code>; mutable variables are initialized with <code class="language-plaintext highlighter-rouge">var</code></li>
</ul>

<h3 id="rust">Rust</h3>

<blockquote>
  <p><a href="https://www.rust-lang.org/">Rust</a> is a “language empowering everyone to build reliable and efficient software.”</p>
</blockquote>

<ul>
  <li>O1 - has structs with implementation methods</li>
  <li>O2 - everything is <code class="language-plaintext highlighter-rouge">private</code> by default; <code class="language-plaintext highlighter-rouge">pub</code> makes it public</li>
  <li>O3 - uses traits for creating subtypes</li>
  <li>F1 - functions are first-class (also supports anonymous functions)</li>
  <li>C1 - variables are immutable by default; mutable variables are designated by <code class="language-plaintext highlighter-rouge">mut</code></li>
</ul>

<h3 id="swift">Swift</h3>

<blockquote>
  <p><a href="https://www.swift.org/">Swift</a> is a “general-purpose programming language built using a modern approach to safety, performance, and software design patterns.”</p>
</blockquote>

<ul>
  <li>O1 - has regular classes (also enums and structs)</li>
  <li>O2 - class properties/methods can be made <code class="language-plaintext highlighter-rouge">private</code></li>
  <li>O3 - uses protocols for creating subtypes</li>
  <li>F1 - functions are first-class (also supports anonymous functions)</li>
  <li>C1 - immutable variables are initialized with <code class="language-plaintext highlighter-rouge">let</code>; mutable variables are initialized with <code class="language-plaintext highlighter-rouge">var</code></li>
</ul>

<h2 id="why-should-your-team-pick-an-inclusive-language">Why should your team pick an inclusive language?</h2>

<p>Successful software development requires solving two kinds of problems - technical and human.</p>

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Junior programmer&#39;s bookshelf: 90% APIs and programming languages; Senior programmer&#39;s bookshelf: 80% applied psychology.</p>&mdash; ☕ J. B. Rainsberger (@jbrains) <a href="https://twitter.com/jbrains/status/616228270841962496?ref_src=twsrc%5Etfw">July 1, 2015</a></blockquote>
<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>I believe inclusive languages offer benefits on both of these fronts. On the technical side, neither style is universally superior. The object-oriented approach is usually better if your system operates on things and new features typically involve adding new things (rather than new operations). On the other hand, if new features typically require new operations then a functional style may be a better fit<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup>.</p>

<p>They can also be used in conjunction; <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">clean architecture</a> may be a good model. Following this approach, you can model your domain and write all of your core business logic using functional code and follow an object-oriented style at the adapter and interface layers.</p>

<p>I believe that providing your teammates with the ability to code as they want to, using the paradigm of their choice, will increase team happiness and morale. I hope it also encourages conversations and teaching moments from both sides. Will you be more productive? Will you create a better design? Will you get a better product? I don’t know. I haven’t tried this experiment myself.</p>

<h2 id="next-steps">Next steps</h2>

<p>Which language should I pick? Here are a few questions to help you make a decision.</p>

<ul>
  <li>Are you doing systems programming? -&gt; Rust</li>
  <li>Are you working on iOS? -&gt; Swift</li>
  <li>Are you working on Android? -&gt; Kotlin</li>
  <li>Do you need to interoperate with other Java code? -&gt; Scala/Kotlin</li>
</ul>

<p>If you don’t identify strongly with any of the questions above, you may want to consider a language that is easier to learn (especially if you are teaching an entire team). Based on the collective background of the team, here are my recommendations:</p>

<p>If you are coming from a Java background…</p>

<blockquote>
  <p>kotlin &lt; scala &lt; swift &lt; rust</p>
</blockquote>

<p>If you are coming from an Objective-C background…</p>

<blockquote>
  <p>swift &lt; kotlin &lt; rust &lt; scala</p>
</blockquote>

<p>Still unsure? Ok, Ok, don’t twist my arm. Pick Kotlin :)</p>

<h2 id="conclusion">Conclusion</h2>

<blockquote>
  <p>You can write crap code in any paradigm. - Dave Farley</p>
</blockquote>

<p>There is clear division between those who use more mainstrain (i.e. object-oriented) languages and those who use functional languages. It is a “them vs. us” mentality, but I believe there is a middle ground where these two crowds can meet, learn, develop, and succeed together. And I believe this middle ground is an <em>inclusive</em> programming language.</p>

<p>Thanks for reading!</p>

<h4 id="footnotes">Footnotes</h4>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p><a href="https://homes.cs.aau.dk/~normark/prog3-03/html/notes/paradigms_themes-paradigm-overview-section.html#paradigms_oo-paradigm-overview_title_1">Object-oriented paradigm</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>“Why Functional Programming Should Be the Future of Software Development,” IEEE Spectrum, Oct. 23, 2022.  [Online]. Available: https://spectrum.ieee.org/functional-programming. [Accessed: Nov. 14, 2022] <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>Subtyping is also known as interface inheritance, whereas subclassing is known as implementation inheritance or code inheritance (see <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov substitution principle</a>). <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>A pure function is a function that, given the same input, will always return the same output and does not have any observable side effect (from <a href="https://mostly-adequate.gitbook.io/mostly-adequate-guide/ch03">Professor Frisby’s Mostly Adequate Guide to Functional Programming</a>) <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>A side effect is a change of system state or observable interaction with the outside world that occurs during the calculation of a result. Examples include: reading a file, inserting a record into a database, making an http call, printing to the screen, or getting user input. <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>This means the language supports passing functions as arguments to other functions, returning them as the values from other functions, and assigning them to variables or storing them in data structures <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>Several languages just missed the cut. C#, C++, Java, and Go meet all the conditions except that mutable variables are not designated. F# and OCaml actually met all the criteria, but I do not believe that the average object-oriented programmer would be comfortable using them. <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>Philip Wadler named this the <a href="http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt">expression problem</a>. Another good reference <a href="https://www.cs.cornell.edu/courses/cs3110/2015fa/l/25-expression/lec.pdf">here</a>. <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Daniel Felps</name><email>dlfelps@gmail.com</email></author><category term="inclusive" /><category term="programming-languages" /><category term="kotlin" /><category term="scala" /><category term="rust" /><category term="swift" /><category term="functional" /><category term="object-oriented" /><summary type="html"><![CDATA[This post explores the possibility of using inclusive programming languages, i.e. ones that successfully accommodate functional and object-oriented programming styles in a single codebase.]]></summary></entry><entry><title type="html">Experiment 08</title><link href="https://dlfelps.github.io/2022/10/03/DSL3.html" rel="alternate" type="text/html" title="Experiment 08" /><published>2022-10-03T00:00:00+00:00</published><updated>2022-10-03T00:00:00+00:00</updated><id>https://dlfelps.github.io/2022/10/03/DSL3</id><content type="html" xml:base="https://dlfelps.github.io/2022/10/03/DSL3.html"><![CDATA[<p>The final post explains how to use an external <strong>domain specific language</strong> to load records after compile time!</p>

<h2 id="introduction">Introduction</h2>

<p>In the previous two posts we explored several ways to model a simple stock trading domain using syntax that is available (or extendable) within F#. This can be described as an <em>internal</em> domain specific language; the biggest limitation with this approach is that all data must be entered before the program is compiled - not very realistic if you want to trade stocks regularly. This post explores how to create an <em>external</em> domain specific language that can be used to load records after compile time.</p>

<h2 id="parser-combinators">Parser combinators</h2>

<p>The most common way to load text data is a delimted text loader, but this only works if your input is structured (i.e. every column of data is aligned). For this post, I want to use a more powerful tool - parser combinators. Parser combinators implement a formal grammar over the input, which we need to interpret a domain specific language. But this post is not a full parser combinator tutorial. In fact, we will use the <code class="language-plaintext highlighter-rouge">parse</code> computation expression from the <a href="https://github.com/stephan-tolksdorf/fparsec">FParsec</a> library instead of the more tradional (and recommended) parser combinator symbols (e.g <code class="language-plaintext highlighter-rouge">&lt;|&gt;</code>, <code class="language-plaintext highlighter-rouge">.&lt;&lt;.</code>, … ). For a deeper dive, see these tutorials <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>. To demonstrate the power of this approach, I will use a parser that can interpret the syntax from either data model 2a or 2b from <a href="/2022/10/02/DSL2.html">post #2</a> in this series. Here are a few examples of valid inputs:</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">Buy 4 SharesOf MSFT At 258.32 AllOrNone
Sell 3 SharesOf META At 158.71 
Sell 6 GOOGL 106.08</span></code></pre></figure>

<h2 id="parser-combinator-workflow-overview">Parser combinator workflow overview</h2>

<p>I find it easiest to follow this code by starting at the result and working backwards. Here is an overview of how the pieces fit together before we dig into the code (arrows are labeled with output type).</p>

<p><img src="/assets/images/mermaid-diagram-2022-09-27-070837.svg" alt="Parser combinator program flow" title="Parser combinator program flow" /></p>

<h2 id="step-3-runparseronfile">Step 3: runParserOnFile</h2>

<p>We begin with the final step - to run the complete parser on our input file. Here is the code:</p>

<figure class="highlight"><pre><code class="language-fsharp" data-lang="fsharp"><span class="k">let</span> <span class="n">result</span><span class="p">:</span> <span class="nc">ParserResult</span><span class="p">&lt;</span><span class="nc">Trade</span> <span class="kt">list</span><span class="p">,</span><span class="kt">unit</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">runParserOnFile</span> <span class="p">(</span><span class="n">many</span> <span class="n">parseTrade</span><span class="p">)</span> <span class="bp">()</span> <span class="s2">"input.txt"</span> <span class="nn">System</span><span class="p">.</span><span class="nn">Text</span><span class="p">.</span><span class="nn">Encoding</span><span class="p">.</span><span class="nc">ASCII</span>

<span class="k">let</span> <span class="n">trades</span><span class="p">:</span> <span class="nc">Trade</span> <span class="kt">list</span> <span class="p">=</span> 
  <span class="k">match</span> <span class="n">result</span> <span class="k">with</span>
  <span class="p">|</span> <span class="nc">Success</span> <span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nc">Trade</span> <span class="kt">list</span><span class="o">,_,_)</span> <span class="p">-&gt;</span> <span class="n">x</span>
  <span class="p">|</span> <span class="p">_</span> <span class="p">-&gt;</span> <span class="bp">[]</span></code></pre></figure>

<p>The code uses the a built-in <code class="language-plaintext highlighter-rouge">FParsec</code> function called <code class="language-plaintext highlighter-rouge">runParserOnFile</code>, which takes the following arguments:</p>
<ul>
  <li>parser <code class="language-plaintext highlighter-rouge">(many parseTrade)</code></li>
  <li>initial user state <code class="language-plaintext highlighter-rouge">()</code></li>
  <li>input file <code class="language-plaintext highlighter-rouge">input.txt</code></li>
  <li>file encoding  <code class="language-plaintext highlighter-rouge">System.Text.Encoding.ASCII</code></li>
</ul>

<p>The parser argument combines two functions: the built-in <code class="language-plaintext highlighter-rouge">FParsec</code> function <code class="language-plaintext highlighter-rouge">many</code><sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup> and our custom parser <code class="language-plaintext highlighter-rouge">parseTrade</code>, which we describe in the next section.  If the file is parsed successfully then we can extract our list of trades from the <code class="language-plaintext highlighter-rouge">ParseResult</code> type.</p>

<h2 id="step-2-parsetrade">Step 2: parseTrade</h2>

<p>The basic idea with this parser is that we are composing<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup> many simple parsers into a more complex parser that captures the grammar/rules of our domain specific language. Here is the finished parser:</p>

<figure class="highlight"><pre><code class="language-fsharp" data-lang="fsharp"><span class="k">let</span> <span class="n">parseTrade</span> <span class="p">=</span>
  <span class="n">parse</span> <span class="p">{</span>
    <span class="k">let</span><span class="o">!</span> <span class="n">buyOrSell</span> <span class="p">=</span> <span class="n">parseTransaction</span>
    <span class="k">let</span><span class="o">!</span> <span class="n">numShares</span> <span class="p">=</span> <span class="n">parseNumShares</span>         
    <span class="k">do</span><span class="o">!</span> <span class="n">optionalIgnore</span> <span class="s2">"SharesOf"</span>    
    <span class="k">let</span><span class="o">!</span> <span class="n">ticker</span> <span class="p">=</span> <span class="n">parseTicker</span>
    <span class="k">do</span><span class="o">!</span> <span class="n">optionalIgnore</span> <span class="s2">"At"</span>
    <span class="k">let</span><span class="o">!</span> <span class="n">price</span> <span class="p">=</span> <span class="n">parsePrice</span>
    <span class="k">let</span><span class="o">!</span> <span class="n">allOrNone</span> <span class="p">=</span> <span class="n">parsePortion</span> 

    <span class="k">return</span> <span class="p">{</span><span class="n">buyOrSell</span> <span class="p">=</span> <span class="n">buyOrSell</span><span class="p">;</span> <span class="n">numShares</span> <span class="p">=</span> <span class="n">numShares</span><span class="p">;</span> <span class="n">ticker</span> <span class="p">=</span> <span class="n">ticker</span><span class="p">;</span> <span class="n">price</span> <span class="p">=</span> <span class="n">price</span><span class="p">;</span> <span class="n">allOrNone</span> <span class="p">=</span> <span class="n">allOrNone</span><span class="p">}</span>
  <span class="p">}</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">parse</code> computation expression does a lot for us here. Under the hood, it threads together the sequence of assignments so that consecutive parsers are linked. The basic idea is shown in the diagram below.</p>

<p><img src="/assets/images/mermaid-diagram-2022-09-29-100911.svg" alt="Parse computation expression" title="Parse computation expression" /></p>

<p>Each call parses a different part of the transaction. We will examine a few of these parsers more closely in the following section, but for now just try to understand how this works at a high level.</p>

<p><code class="language-plaintext highlighter-rouge">parseTrade</code> proceeds by parsing (or ignoring) the necessary values to create a <code class="language-plaintext highlighter-rouge">Trade</code> type and return it<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup>.</p>

<h2 id="step-1-individual-token-parsers">Step 1: individual token parsers</h2>

<p>Each of snippet of code below is a parser that detects a specific token from our domain specific language. We will look at a few of these smaller parsers to highlight some fundamental parsing elements. The full code listing can be found <a href="https://github.com/dlfelps/dsl-examples/blob/main/exp08-parser-combinator.fsx">here</a>. The first snippet detects the token <em>Buy</em> or <em>Sell</em>.</p>

<h3 id="do-let-pstring-choice"><code class="language-plaintext highlighter-rouge">do!</code>, <code class="language-plaintext highlighter-rouge">let!</code>, <code class="language-plaintext highlighter-rouge">pstring</code>, <code class="language-plaintext highlighter-rouge">choice</code></h3>

<figure class="highlight"><pre><code class="language-fsharp" data-lang="fsharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="k">let</span> <span class="n">convertTransaction</span> <span class="n">inputString</span> <span class="p">=</span> 
  <span class="k">match</span> <span class="n">inputString</span> <span class="k">with</span>
  <span class="p">|</span> <span class="s2">"Sell"</span> <span class="p">-&gt;</span> <span class="nc">Sell</span>
  <span class="p">|</span> <span class="p">_</span> <span class="p">-&gt;</span> <span class="nc">Buy</span>

<span class="k">let</span> <span class="n">parseTransaction</span> <span class="p">=</span> 
  <span class="n">parse</span> <span class="p">{</span>
    <span class="k">do</span><span class="o">!</span> <span class="n">spaces</span>
    <span class="k">let</span><span class="o">!</span> <span class="n">buyOrSellString</span> <span class="p">=</span> <span class="n">choice</span> <span class="o">[(</span><span class="n">pstring</span> <span class="s2">"Buy"</span><span class="o">);(</span><span class="n">pstring</span> <span class="s2">"Sell"</span><span class="o">)]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">convertTransaction</span> <span class="n">buyOrSellString</span><span class="p">)</span>
  <span class="p">}</span> 
</pre></td></tr></tbody></table></code></pre></figure>

<p>Notice that <code class="language-plaintext highlighter-rouge">parseTransaction</code> is itself another <code class="language-plaintext highlighter-rouge">parse</code> computation expression. First I will describe the purpose of each line, then we will discuss syntax.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Line 08</code> Skip any whitespace</li>
  <li><code class="language-plaintext highlighter-rouge">Line 09</code> Check if the input begins with “Buy” or “Sell”</li>
  <li><code class="language-plaintext highlighter-rouge">Line 10</code> If successful, convert the string to its corresponding type (e.g. <code class="language-plaintext highlighter-rouge">Buy</code> type) and return</li>
</ul>

<p>Now let’s revist any new syntax. The <code class="language-plaintext highlighter-rouge">do</code> keyword in F# requires the following expression to return <code class="language-plaintext highlighter-rouge">unit</code>. Similarly, the <code class="language-plaintext highlighter-rouge">do!</code> notation on <code class="language-plaintext highlighter-rouge">Line 08</code> is used in a computation expression when the following expression returns a “unit-like” value<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup>.</p>

<p><code class="language-plaintext highlighter-rouge">Line 09</code> uses two new commands. <code class="language-plaintext highlighter-rouge">pstring</code> creates a parser that succeeds if it encounters its argument (i.e. “Buy” or “Sell”) and fails otherwise. <code class="language-plaintext highlighter-rouge">choice</code> composes these two parsers in a way such that it returns the value of the first successful parser. If both fail then the <code class="language-plaintext highlighter-rouge">choice</code> parser fails.</p>

<p>The difference between <code class="language-plaintext highlighter-rouge">let</code> and <code class="language-plaintext highlighter-rouge">let!</code> is analogous to <code class="language-plaintext highlighter-rouge">do</code> and <code class="language-plaintext highlighter-rouge">do!</code> - <code class="language-plaintext highlighter-rouge">let!</code> binds a name to an value that is within a computation expression context <sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>.</p>

<h3 id="pint32-pfloat"><code class="language-plaintext highlighter-rouge">pint32</code>, <code class="language-plaintext highlighter-rouge">pfloat</code></h3>

<figure class="highlight"><pre><code class="language-fsharp" data-lang="fsharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">let</span> <span class="n">parseNumShares</span> <span class="p">=</span> 
  <span class="n">parse</span> <span class="p">{</span>
    <span class="k">do</span><span class="o">!</span> <span class="n">spaces</span>
    <span class="k">let</span><span class="o">!</span> <span class="n">numShares</span> <span class="p">=</span> <span class="n">pint32</span>
    <span class="k">return</span> <span class="n">numShares</span>
  <span class="p">}</span> 
</pre></td></tr></tbody></table></code></pre></figure>

<p>Stepping through this snippet:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Line 03</code> Skip any whitespace</li>
  <li><code class="language-plaintext highlighter-rouge">Line 04</code> Read an integer</li>
  <li><code class="language-plaintext highlighter-rouge">Line 05</code> Return the integer</li>
</ul>

<p>You will recognize most of the syntax here, with the exception of <code class="language-plaintext highlighter-rouge">pint32</code>, which parses 1 or more digits as an integer. Although not shown here <code class="language-plaintext highlighter-rouge">parsePrice</code> uses the related function <code class="language-plaintext highlighter-rouge">pfloat</code>.</p>

<h3 id="skipmany-return"><code class="language-plaintext highlighter-rouge">skipMany</code>, <code class="language-plaintext highlighter-rouge">return!</code></h3>

<figure class="highlight"><pre><code class="language-fsharp" data-lang="fsharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">let</span> <span class="n">optionalIgnore</span> <span class="n">str</span> <span class="p">=</span> 
  <span class="n">parse</span> <span class="p">{</span>
    <span class="k">do</span><span class="o">!</span> <span class="n">spaces</span>
    <span class="k">return</span><span class="o">!</span> <span class="n">skipMany</span> <span class="p">(</span><span class="n">pstring</span> <span class="n">str</span><span class="p">)</span>    
  <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This code snippet:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Line 03</code> Skips any whitespace</li>
  <li><code class="language-plaintext highlighter-rouge">Line 04</code> Creates a parser for the function argument <code class="language-plaintext highlighter-rouge">str</code> and skips it if found and returns <em>without</em> wrapping in a parser context</li>
</ul>

<p>This function is used to create parsers for our placeholder types (i.e. <code class="language-plaintext highlighter-rouge">SharesOf</code> and <code class="language-plaintext highlighter-rouge">At</code>). <code class="language-plaintext highlighter-rouge">skipMany</code> will apply the parser 0 or more times and throw away any tokens found. The careful reader will also notice the use of <code class="language-plaintext highlighter-rouge">return!</code> instead of <code class="language-plaintext highlighter-rouge">return</code>. The simple rule is use <code class="language-plaintext highlighter-rouge">return</code> if you need to wrap a value in the context of the computation expression (i.e. a parser) and use <code class="language-plaintext highlighter-rouge">return!</code> if the value already has the correct context<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">8</a></sup>.</p>

<h3 id="many1-asciiupper"><code class="language-plaintext highlighter-rouge">many1</code>, <code class="language-plaintext highlighter-rouge">asciiUpper</code></h3>

<figure class="highlight"><pre><code class="language-fsharp" data-lang="fsharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="k">let</span> <span class="n">convertTicker</span> <span class="n">inputString</span> <span class="p">=</span> 
  <span class="k">match</span> <span class="n">inputString</span> <span class="k">with</span>
  <span class="p">|</span> <span class="s2">"GOOGL"</span> <span class="p">-&gt;</span> <span class="nc">GOOGL</span>
  <span class="p">|</span> <span class="s2">"META"</span> <span class="p">-&gt;</span> <span class="nc">META</span>
  <span class="p">|</span> <span class="p">_</span> <span class="p">-&gt;</span> <span class="nc">MSFT</span>

<span class="k">let</span> <span class="n">parseTicker</span> <span class="p">=</span> 
  <span class="n">parse</span><span class="p">{</span>
    <span class="k">do</span><span class="o">!</span> <span class="n">spaces</span>
    <span class="k">let</span><span class="o">!</span> <span class="n">tickerCharList</span> <span class="p">=</span> <span class="p">(</span><span class="n">many1</span> <span class="n">asciiUpper</span><span class="p">)</span> 
    <span class="k">let</span> <span class="n">tickerString</span> <span class="p">=</span>  <span class="n">tickerCharList</span> <span class="p">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="kt">string</span> <span class="p">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">reduce</span> <span class="o">(+)</span>
    <span class="k">let</span> <span class="n">ticker</span> <span class="p">=</span> <span class="n">convertTicker</span> <span class="n">tickerString</span>
    <span class="k">return</span> <span class="n">ticker</span>
  <span class="p">}</span> 
</pre></td></tr></tbody></table></code></pre></figure>

<p>This code snippet:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Line 09</code> Skips any whitespace</li>
  <li><code class="language-plaintext highlighter-rouge">Line 10</code> Creates a parser that accepts one or more capitalized characters in ‘A’ - ‘Z’</li>
  <li><code class="language-plaintext highlighter-rouge">Line 11</code> Converts the character list into a single string</li>
  <li><code class="language-plaintext highlighter-rouge">Line 12</code> Maps the string to the corresponding <code class="language-plaintext highlighter-rouge">Stock</code> type</li>
</ul>

<p>This parser demonstrates two more primitive functions - <code class="language-plaintext highlighter-rouge">many1</code> and <code class="language-plaintext highlighter-rouge">asciiUpper</code>. Combined they create a parser that accepts 1 or more upper case ASCII characters. The other notable feature about <code class="language-plaintext highlighter-rouge">parseTicker</code> is that it mixes the use of <code class="language-plaintext highlighter-rouge">let!</code> and <code class="language-plaintext highlighter-rouge">let</code>. The <code class="language-plaintext highlighter-rouge">let!</code> on <code class="language-plaintext highlighter-rouge">Line 10</code> unwraps the parser context from the expresson on the right to bind <code class="language-plaintext highlighter-rouge">ticketCharList</code> to a list of characters. The following two lines perform operations on regular F# types so they use the <code class="language-plaintext highlighter-rouge">let</code> keyword.</p>

<h3 id="preturn"><code class="language-plaintext highlighter-rouge">preturn</code></h3>

<figure class="highlight"><pre><code class="language-fsharp" data-lang="fsharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">let</span> <span class="n">parsePortion</span> <span class="p">=</span> 
  <span class="n">parse</span> <span class="p">{</span>
    <span class="k">do</span><span class="o">!</span> <span class="n">spaces</span>
    <span class="k">let</span><span class="o">!</span> <span class="n">portion</span> <span class="p">=</span> <span class="n">choice</span> <span class="o">[(</span><span class="n">pstring</span> <span class="s2">"AllOrNone"</span><span class="o">);</span> <span class="p">(</span><span class="n">pstring</span> <span class="s2">"Partial"</span><span class="o">);</span> <span class="p">(</span><span class="n">preturn</span> <span class="s2">"AllOrNone"</span><span class="o">)]</span>
    <span class="k">return</span> <span class="n">portion</span> <span class="p">=</span> <span class="s2">"AllOrNone"</span>
  <span class="p">}</span> 
</pre></td></tr></tbody></table></code></pre></figure>

<p>Stepping through this snippet:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Line 03</code> Skip any whitespace</li>
  <li><code class="language-plaintext highlighter-rouge">Line 04</code> Check if the input begins with “AllOrNone” or “Partial”; if neither return “AllOrNone”</li>
  <li><code class="language-plaintext highlighter-rouge">Line 05</code> Return true if previous assignment was “AllOrNone”</li>
</ul>

<p>This parser is very similar to <code class="language-plaintext highlighter-rouge">parseTransaction</code> but it demonstrates use of the <code class="language-plaintext highlighter-rouge">preturn</code> primitive. <code class="language-plaintext highlighter-rouge">preturn</code> always succeeds with the provided value; here I use it as a default value <code class="language-plaintext highlighter-rouge">choice</code> parser by providing it as a final value (only used if all other choices fail).</p>

<p>At this point it is probably worthwhile to revist <a href="#step-2-parsetrade">Step 2</a> for a better understanding of the composition of <code class="language-plaintext highlighter-rouge">parseTrade</code>. The code listing for this series can be found <a href="https://github.com/dlfelps/dsl-examples">here</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<blockquote>
  <p>“A complex system that works is invariably found to have evolved from a simple system that worked.” - Gall’s law (John Gall)</p>
</blockquote>

<p>My favorite three things about parser combinators are:</p>
<ol>
  <li>There are many built-in primitive parsers</li>
  <li>Simple parsers are easy to create and test</li>
  <li>Complex parsers are easy to create by composing simple parsers</li>
</ol>

<p>I hope this post has demonstrated a useful application of parser combinators. But it may not have been as successful in convincing you the value of external domain specific languages - that’s probably because I can’t honestly make a good argument for them. If your program reads input from another machine then it will certainly be of a structured form (e.g. JSON). If your program reads input from a human then I doubt a domain specific language is the most natural way for the human to input data. I can’t think of a realistic example where a domain specific language would be better than a graphical user interface.</p>

<p><img src="/assets/images/ETRADE-mobile-stock-quote.png" alt="Stock App" title="Stock App" /></p>

<p>On the other hand, I have benefited from using <strong>embedded domain modeling</strong>. Using natural notions about the world within my code has made it easier to write, reason about, and revisit. If I have piqued your interest in domain modeling, then I would recommend browsing the related topics below. I believe each topic has something different to offer  (like the <a href="https://en.wikipedia.org/wiki/Blind_men_and_an_elephant">parable of the blind men and the elephant</a>).</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">Beginner resources</th>
      <th style="text-align: center">Author</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">TDD</td>
      <td style="text-align: center"><a href="https://blog.ploeh.dk/2015/08/10/type-driven-development/">Type Driven Development</a></td>
      <td style="text-align: center">Mark Seemann</td>
    </tr>
    <tr>
      <td style="text-align: center">DDD-light</td>
      <td style="text-align: center"><a href="https://pragprog.com/titles/swdddf/domain-modeling-made-functional/">Domain Modeling Made Functional</a></td>
      <td style="text-align: center">Scott Wlascin</td>
    </tr>
    <tr>
      <td style="text-align: center">APIs</td>
      <td style="text-align: center"><a href="http://www.infoq.com/presentations/effective-api-design">How to Design a Good API &amp; Why it Matters</a></td>
      <td style="text-align: center">Josh Bloch</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">Advanced resources</th>
      <th style="text-align: center">Author</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">DDD</td>
      <td style="text-align: center"><a href="https://www.youtube.com/watch?v=pMuiVlnGqjk">Domain Driven Design</a></td>
      <td style="text-align: center">Eric Evans</td>
    </tr>
    <tr>
      <td style="text-align: center">DSL</td>
      <td style="text-align: center"><a href="https://martinfowler.com/books/dsl.html">Domain Specific Languages</a></td>
      <td style="text-align: center">Martin Fowler</td>
    </tr>
    <tr>
      <td style="text-align: center">MDD</td>
      <td style="text-align: center">Model-driven development: The good, the bad, and the ugly</td>
      <td style="text-align: center">Hailpern/Tarr</td>
    </tr>
    <tr>
      <td style="text-align: center">LOP</td>
      <td style="text-align: center">Language Oriented Programming</td>
      <td style="text-align: center">Ward</td>
    </tr>
  </tbody>
</table>

<h4 id="footnotes">Footnotes</h4>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p><a href="http://www.quanttec.com/fparsec/tutorial.html">FParsec Tutorial</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p><a href="https://fsharpforfunandprofit.com/posts/understanding-parser-combinators/">fsharpforfunandprofit </a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p><code class="language-plaintext highlighter-rouge">many</code> indicates that we expect to run <code class="language-plaintext highlighter-rouge">parseTrade</code> zero or more times (depending on the number of lines in our input file). <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>Instead of using the more traditional parser combinator functions (e.g. <code class="language-plaintext highlighter-rouge">&lt;|&gt;</code>, <code class="language-plaintext highlighter-rouge">.&gt;&gt;.</code>, …) I elected to use a more familiar syntax with the <code class="language-plaintext highlighter-rouge">parse</code> computation expression from FParsec. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>Within a computation expression, <code class="language-plaintext highlighter-rouge">return</code> performs an operation that is the opposite of <code class="language-plaintext highlighter-rouge">let!</code> - it wraps the value within a context specified by the computation expression. In this case the value has a <code class="language-plaintext highlighter-rouge">Trade</code> type, so <code class="language-plaintext highlighter-rouge">parseTrade</code> actually returns a value of type <code class="language-plaintext highlighter-rouge">Parser&lt;Trade, unit&gt;</code>. <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>The function <a href="https://www.quanttec.com/fparsec/reference/charparsers.html#members.spaces"><code class="language-plaintext highlighter-rouge">spaces</code></a> has type <code class="language-plaintext highlighter-rouge">Parser&lt;unit,'u&gt;</code>, which is unit-like within this context. <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>In this case the context is <code class="language-plaintext highlighter-rouge">ParserResult&lt;T&gt;</code>; <code class="language-plaintext highlighter-rouge">let!</code> binds the type <code class="language-plaintext highlighter-rouge">T</code>. This pattern is commonly used with the <code class="language-plaintext highlighter-rouge">async {}</code> computation expression. <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:8" role="doc-endnote">
      <p>Note that <code class="language-plaintext highlighter-rouge">parseTrade</code> calls this function with <code class="language-plaintext highlighter-rouge">do!</code> since it returns a unit-like parser. <a href="#fnref:8" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Daniel Felps</name><email>dlfelps@gmail.com</email></author><category term="net" /><category term="dsl" /><category term="ddd" /><summary type="html"><![CDATA[The final post explains how to use an external domain specific language to load records after compile time!]]></summary></entry></feed>