<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://dlfelps.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://dlfelps.github.io/" rel="alternate" type="text/html" /><updated>2022-07-08T20:29:26+00:00</updated><id>https://dlfelps.github.io/feed.xml</id><title type="html">.NET Experiments</title><subtitle>Bill Nye meets Bill Gates ;)</subtitle><author><name>Daniel Felps</name><email>dlfelps@gmail.com</email></author><entry><title type="html">Experiment 04</title><link href="https://dlfelps.github.io/2022/07/06/Reproducible-Example.html" rel="alternate" type="text/html" title="Experiment 04" /><published>2022-07-06T00:00:00+00:00</published><updated>2022-07-06T00:00:00+00:00</updated><id>https://dlfelps.github.io/2022/07/06/Reproducible-Example</id><content type="html" xml:base="https://dlfelps.github.io/2022/07/06/Reproducible-Example.html"><![CDATA[<p>In the final post of the series I give a practical example of how to incorporate continuously reproducible strategies into your workflow.</p>

<h2 id="introduction">Introduction</h2>

<p>In the <a href="/2022/06/20/Reproducible-Dotnet-Series.html">first post</a> in this <a href="/tags/reproducible/">series</a> I described the characteristics of reproducible code. In the <a href="/2022/06/25/Reproducible-Foundations.html">second post</a> I described the foundational tools that I use in my approach to creating continuously reproducible code. This final post incorporates the approach into an existing repository.</p>

<h2 id="example">Example</h2>

<p>I selected <a href="https://github.com/fsprojects/FsHttp">FsHttp</a> as a demonstration codebase. FsHttp follows many recommendations of the continuously reproducible mindset (i.e. LTS releases, pinned dependencies), but it lacks continuous integration. I will show two different ways to adopt it.</p>

<h2 id="approach-1-net-variant">Approach #1 (.NET variant)</h2>

<p>The preferred way for .NET projects is to use .NET directly to verify the build. I forked the FsHttp repo and removed some parts that were unnecessary to this blog post. You can find that fork <a href="https://github.com/dlfelps/FsHttp-dotnet">here</a>.</p>

<p>Since the repository is already on Github I will use Github Actions to implement continuous integration. If you use another continuous integration platform you will have to translate this example into that platform’s workflow sytax.</p>

<p>Adding continuous integration is as easy as creating the <code class="language-plaintext highlighter-rouge">.github\workflows</code> folder at the base of the repository and then adding the workflow YAML file, which I named <a href="https://github.com/dlfelps/FsHttp-dotnet/blob/main/.github/workflows/dotnet.yml">dotnet.yml</a> to that folder. Here are the contents of that file:</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="na">name</span><span class="pi">:</span> <span class="s">Dotnet CI</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
  <span class="na">push</span><span class="pi">:</span>
    <span class="na">branches</span><span class="pi">:</span> <span class="pi">[</span> <span class="nv">main</span> <span class="pi">]</span>
  
<span class="na">jobs</span><span class="pi">:</span>     
  <span class="na">build</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-20.04</span>

    <span class="na">steps</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Checkout main</span>
      <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v3</span>

    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Setup .NET</span>
      <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/setup-dotnet@v2</span>
      <span class="na">with</span><span class="pi">:</span>
        <span class="na">dotnet-version</span><span class="pi">:</span> <span class="s">6.0.301</span>

    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Restore dependencies</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">dotnet restore</span>

    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Build</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">dotnet build --no-restore</span>

    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Test</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">dotnet test --verbosity normal</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Now let’s breakdown each step.</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="na">name</span><span class="pi">:</span> <span class="s">Dotnet CI</span>
<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
  <span class="na">push</span><span class="pi">:</span>
    <span class="na">branches</span><span class="pi">:</span> <span class="pi">[</span> <span class="nv">main</span> <span class="pi">]</span>  </code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">name</code> keyword allows you to name the workflow - workflows will be grouped by name under the projects Action tab. The <code class="language-plaintext highlighter-rouge">on</code> keyword allows you to specify the conditions for which this workflow executes - here I only execute the workflow when I push to the <code class="language-plaintext highlighter-rouge">main</code> branch.</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="na">jobs</span><span class="pi">:</span>     
  <span class="na">build</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-20.04</span></code></pre></figure>

<p>The next block defines the sequence of <code class="language-plaintext highlighter-rouge">jobs</code> to execute when the workflow conditions are met. In this workflow I have only one job named <code class="language-plaintext highlighter-rouge">build</code> (define additional jobs at the same indentation level as <code class="language-plaintext highlighter-rouge">build</code>). The <code class="language-plaintext highlighter-rouge">runs-on</code> keyword selects the type of machine to run the job on; other options include <code class="language-plaintext highlighter-rouge">windows-2022</code> and <code class="language-plaintext highlighter-rouge">macos-11</code>. The full list of available options is <a href="https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idruns-on">here</a>. <em>NOTE</em>: prefer <code class="language-plaintext highlighter-rouge">ubuntu-20.04</code> to <code class="language-plaintext highlighter-rouge">ubuntu-latest</code> even though they are currently equivalent; <code class="language-plaintext highlighter-rouge">ubuntu-latest</code> will eventually point to <code class="language-plaintext highlighter-rouge">ubuntu-22.04</code> so it is better to pin the dependency now.</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml">    <span class="na">steps</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Checkout main</span>
      <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v3</span></code></pre></figure>

<p>Each job consists of several <code class="language-plaintext highlighter-rouge">steps</code>; each step includes an optional name and then an action. The first step <code class="language-plaintext highlighter-rouge">uses</code> a Github Action to check out the <code class="language-plaintext highlighter-rouge">main</code> branch. There are several <a href="https://github.com/orgs/actions/repositories">official Github actions</a> and also over 14,000 user contributed actions available through the <a href="https://github.com/marketplace?type=actions">Github Marketplace</a>. I tend to stick to the official actions since there are potentially some <a href="https://www.youtube.com/watch?v=bDG40Y1nPEk">security concerns</a> when using them. Also notice the <code class="language-plaintext highlighter-rouge">@v3</code> appended to the end of the <code class="language-plaintext highlighter-rouge">actions/checkout</code> action - this pins the version of the action.</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml">    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Setup .NET</span>
      <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/setup-dotnet@v2</span>
      <span class="na">with</span><span class="pi">:</span>
        <span class="na">dotnet-version</span><span class="pi">:</span> <span class="s">6.0.301</span></code></pre></figure>

<p>The next step users another offical action to install .NET 6. This action is actually redundant since the <code class="language-plaintext highlighter-rouge">ubuntu-20.04</code> runner actually comes <a href="https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-Readme.md">pre-installed</a> with lots of useful software including .NET 6. However, I chose to add this step since this was an explicit dependency that the build relies upon. I can’t be sure that Github will always include it with the runner so I want to explicitly install it.</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml">    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Restore dependencies</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">dotnet restore</span>

    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Build</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">dotnet build --no-restore</span>

    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Test</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">dotnet test --verbosity normal</span></code></pre></figure>

<p>The final three steps restore the project’s dependencies, build, and test the project.</p>

<h3 id="visualizing-the-workflow">Visualizing the workflow</h3>

<p>If you push this workflow file to the repo’s <code class="language-plaintext highlighter-rouge">main</code> branch it will execute for the first time. You can watch its progress by clicking on the <code class="language-plaintext highlighter-rouge">Actions</code> button from the repository’s main page. Then click on the most recent run, which will have the same name as the message of the most recent commit.</p>

<p><img src="/assets/images/workflow1.png" alt="Github Actions screenshot #1" title="Github Actions screenshot #1" /></p>

<p>Then you can visualize the jobs contained within the workflow (there was only a single job named <code class="language-plaintext highlighter-rouge">build</code> in <code class="language-plaintext highlighter-rouge">dotnet.yml</code>). Clicking the <code class="language-plaintext highlighter-rouge">build</code> box will provide details of each step.</p>

<p><img src="/assets/images/workflow2.png" alt="Github Actions screenshot #2" title="Github Actions screenshot #2" /></p>

<p>Here we see the names given to each of the steps along with some automatic setup and teardown steps.</p>

<p><img src="/assets/images/workflow3.png" alt="Github Actions screenshot #3" title="Github Actions screenshot #3" /></p>

<h3 id="results">Results</h3>

<p>In the <a href="/2022/06/25/Reproducible-Foundations.html">previous post</a> we defined the following criteria for reprodicible software:</p>

<blockquote>
  <ol>
    <li>Build from any platform <strong>with the help of one pre-installed dependency</strong></li>
    <li>Satisfy #1 in a standard and lightweight way across codebases</li>
  </ol>
</blockquote>

<p>Did we satisfy them? Adding a Github workflow is certainly lightweight and repeatable since it will work for most .NET projects with little modification. But we didn’t explicity verify the first critieria since we only tested from Ubuntu. If you want to explicitly test additional platforms then I would recommend defining additional jobs that build in different environments:</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="na">jobs</span><span class="pi">:</span>     
  <span class="na">build-linux</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-20.04</span>
    <span class="c1"># steps...</span>
  
  <span class="na">build-windows</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">windows-2022</span>
    <span class="c1"># steps...</span>

  <span class="na">build-macos</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">macos-11</span>
    <span class="c1"># steps...</span></code></pre></figure>

<p>But since I assume that .NET 6 is installed on the host platform I don’t really need to test the other operating systems - if it compiles on one platform it will compile on the others because .NET compiles to Common Intermediate Language. The runtimes for each platform differ, but that is an isolated component that I don’t feel the need to verify. I think this is a big win for Microsoft and one of the reasons that I ❤️ .NET!</p>

<h2 id="approach-2-not-net-variant">Approach #2 (Not .NET variant)</h2>

<p>How difficult is it to translate Approach #1 into another language? I was able to convert a popular Golang repo in about 5 minutes. You will notice the similarities in the workflow; the full repo is <a href="https://github.com/dlfelps/cobra-go">here</a>.</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="na">name</span><span class="pi">:</span> <span class="s">Go CI</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
  <span class="na">push</span><span class="pi">:</span>
    <span class="na">branches</span><span class="pi">:</span> <span class="pi">[</span> <span class="nv">main</span> <span class="pi">]</span>
  
<span class="na">jobs</span><span class="pi">:</span>     
  <span class="na">build-linux</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-20.04</span>

    <span class="na">steps</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Checkout commit</span>
      <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v3</span>

    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Setup Go</span>
      <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/setup-go@v3</span>
      <span class="na">with</span><span class="pi">:</span>
        <span class="na">go-version</span><span class="pi">:</span> <span class="m">1.18</span>

    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Build</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">go build</span>

    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Test</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">go test .</span>

  <span class="na">build-macos</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">macos-11</span>
    <span class="c1"># steps...</span>

  <span class="na">build-windows</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">windows-2022</span>
    <span class="c1"># steps...</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="results-1">Results</h3>

<p>This variant also meets the necessary criteria with one gotcha - since Golang compiles directly to machine code you need to add additional build jobs to test other platforms. Definitely still doable since Github also includes Golang in its machine images.</p>

<h2 id="approach-3-docker-variant">Approach #3 (Docker variant)</h2>

<p><em>Basic knowledge of Docker required to follow this tutorial.</em></p>

<p>I know a lot of developers that really love Docker and they use it for everything. I use Docker to deploy services, but not for my development environment. It tends to add an extra step that I don’t really want while I am coding. But I also don’t tend to work on multiple projects simultaneously (each using a different version of something). Still, its simple enough to integrate Docker into the continuous integration workflow. If I was required to build a Docker image for a project then this is probably how I would do it (rather than building it locally). Here is the full <a href="https://github.com/dlfelps/FsHttp-dotnet">repo</a> and here are the contents of its workflow YAML:</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="na">name</span><span class="pi">:</span> <span class="s">Docker Image CI</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">push</span><span class="pi">:</span>
    <span class="na">branches</span><span class="pi">:</span> <span class="pi">[</span> <span class="nv">main</span> <span class="pi">]</span>

<span class="na">jobs</span><span class="pi">:</span>

  <span class="na">build</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>

    <span class="na">steps</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Checkout commit</span>
      <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v3</span>

    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Build the Docker image</span>
      <span class="na">run</span><span class="pi">:</span> <span class="s">docker build . --file Dockerfile --tag fshttp:$(date +%s)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The workflow only includes two steps - one to checkout the <code class="language-plaintext highlighter-rouge">main</code> branch and another to build the <code class="language-plaintext highlighter-rouge">Dockerfile</code>. The remaining steps are now inside the <code class="language-plaintext highlighter-rouge">Dockerfile</code>:</p>

<figure class="highlight"><pre><code class="language-docker" data-lang="docker"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">FROM</span><span class="s"> mcr.microsoft.com/dotnet/sdk:6.0</span>
<span class="k">WORKDIR</span><span class="s"> /app</span>

<span class="k">COPY</span><span class="s"> . ./</span>
<span class="k">RUN </span>dotnet restore 
<span class="k">RUN </span>dotnet build <span class="nt">--no-restore</span>
<span class="k">RUN </span>dotnet <span class="nb">test</span> <span class="nt">--verbosity</span> normal
</pre></td></tr></tbody></table></code></pre></figure>

<p>The Dockerfile uses the standard .NET 6 baseimage provided by Microsoft, copies the new commit into the /app folder, and then restore/build/test.</p>

<h3 id="results-2">Results</h3>

<p>This variant is still lightweight, but we must look closely to see if it is truly cross-platform. We have changed our dependency assumption from .NET to Docker - any platform that can run Docker can build this code. If this is a .NET project then any code that successfully compiles to the Common Intermediate Language and passes the test suite will work on any platform (.NET for the win)! But what if its a Golang project? In that case we would need a seperate job and Dockerfile for each platform. But there is no such thing as a macOS Docker image! In conclusion, Approach #3 meets the reproducibility criteria for all .NET projects, but not <em>all</em> projects.</p>

<h2 id="conclusion">Conclusion</h2>

<p>If I did not address your specific use case, please feel free to consult the <a href="https://docs.github.com/en/actions/using-workflows/about-workflows">Github Actions docs</a> for more information. Finally, thanks for reading this series on continuously reproducible code and I hope I have helped you develop a more continuously reproducible mindset! As always, your feedback is appreciated!</p>]]></content><author><name>Daniel Felps</name><email>dlfelps@gmail.com</email></author><category term="reproducible" /><category term="net" /><category term="docker" /><category term="ci/cd" /><summary type="html"><![CDATA[In the final post of the series I give a practical example of how to incorporate continuously reproducible strategies into your workflow.]]></summary></entry><entry><title type="html">Experiment 03</title><link href="https://dlfelps.github.io/2022/06/25/Reproducible-Foundations.html" rel="alternate" type="text/html" title="Experiment 03" /><published>2022-06-25T00:00:00+00:00</published><updated>2022-06-25T00:00:00+00:00</updated><id>https://dlfelps.github.io/2022/06/25/Reproducible-Foundations</id><content type="html" xml:base="https://dlfelps.github.io/2022/06/25/Reproducible-Foundations.html"><![CDATA[<p>This post describes the approach that I use to make my code reproducible. NOTE: I have only tested this on <em>smallish</em> projects and there certainly are other ways to create reproducible software.</p>

<h2 id="introduction">Introduction</h2>

<p>The <a href="/2022/06/20/Reproducible-Dotnet-Series.html">first post</a> in this <a href="/tags/reproducible/">series</a> described the characteristics of reproducible code. This post describes my approach to meeting the following requirements of reproducible software:</p>

<blockquote>
  <ol>
    <li>Build from a clean environment on any platform</li>
    <li>Satisfy #1 in a standard, lightweight, repeatable way across codebases</li>
  </ol>
</blockquote>

<p>My initial attempts at satisfying these requirements failed. Custom build tools (i.e. <a href="https://cakebuild.net/">CAKE</a>/<a href="https://fake.build/">FAKE</a>) were too cumbersome and assumed .NET was already installed (i.e. not a clean environment). Docker dev environments were a quick way to create one-time reproducible builds, but they also assumed Docker was installed. Installing from a purely clean environment seemed at odds with a lightweight build process. So I amended the requirements slightly:</p>

<blockquote>
  <ol>
    <li>Build from any platform <strong>with the help of one pre-installed dependency</strong></li>
    <li>Satisfy #1 in a standard, lightweight, repeatable way across codebases</li>
  </ol>
</blockquote>

<p>This small change was sufficient for me to devise an approach for continuously reproducible code.</p>

<h2 id="my-continuously-reproducible-approach">(My) Continuously reproducible approach</h2>

<p>My approach is essentially continuous integration<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> plus the <a href="https://dlfelps.github.io/2022/06/20/Reproducible-Dotnet-Series.html#the-continuously-reproducible-mindset">continuously reproducible mindset</a>. Continuous integration ensures that the build works now and the continuously reproducible mindset maximizes the chance that it will work even if left dormant for a period of time. I assume that the most recent LTS version of .NET is installed (this is currently .NET 6.0 which can be installed on any major platform); this assumption lets me use .NET to restore dependencies, build, and test the project. For projects outside of .NET, I assume that Docker is installed instead. I provide an example of both of these in the final post.</p>

<p>By following this approach you can verify that your project builds from a (mostly) clean environment and have confidence that it will work continue to work for anyone else for <em>years</em> to come. If you have improvements or would like to share a different approach I would love to hear about it!</p>

<h4 id="footnotes">Footnotes</h4>

<!--

1. Intro
  - need for reproducibility
  - in science
  - in software
  - in machine learning

2. Basic tools
  - Docker (links to learning resources)
  - Gitlab/Github 
  - CI/CD
  - permissive licensing

3. Producing reporducible builds
  - choice of baseline (LTS)
  - provide multiple options (multiple-platforms)
    - local install w/ ci/cd
    - docker-compose local (build)
  - push build complexity to lowest level

4. CI/CD
  - Gitlab runner w/ docker
  - (optional) docker registry

5. Publishing
  - code should be publish to allow someone (most likely yourself) to reproduce it
  - but it shouldnt be required; also provide standalone executables

-->
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Continuous integration is the DevOps practice whereby code changes are regularly merged into a central repository and the entire project is automatically built and tested. Some common platforms for continuous integration are <a href="https://www.jetbrains.com/teamcity/">TeamCity</a>, <a href="https://www.jenkins.io/">Jenkins</a>, <a href="https://circleci.com/">CircleCI</a>, <a href="https://github.com/features/actions">Github Actions</a>, and <a href="https://gitlab.com/">Gitlab</a>. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Daniel Felps</name><email>dlfelps@gmail.com</email></author><category term="reproducible" /><category term="net" /><category term="docker" /><category term="ci/cd" /><summary type="html"><![CDATA[This post describes the approach that I use to make my code reproducible. NOTE: I have only tested this on smallish projects and there certainly are other ways to create reproducible software.]]></summary></entry><entry><title type="html">Experiment 02</title><link href="https://dlfelps.github.io/2022/06/20/Reproducible-Dotnet-Series.html" rel="alternate" type="text/html" title="Experiment 02" /><published>2022-06-20T00:00:00+00:00</published><updated>2022-06-20T00:00:00+00:00</updated><id>https://dlfelps.github.io/2022/06/20/Reproducible-Dotnet-Series</id><content type="html" xml:base="https://dlfelps.github.io/2022/06/20/Reproducible-Dotnet-Series.html"><![CDATA[<p>The next few posts take step back to examine the benefits of creating reproducible software. We will explore:</p>
<ul>
  <li>the continuosly reproducible mindset (this post)</li>
  <li>foundational tools for reproducibility (<a href="/2022/06/25/Reproducible-Foundations.html">Exp 03</a>)</li>
  <li>creating a continuously reproducible .NET project (<a href="/2022/07/06/Reproducible-Example.html">Exp 04</a>)</li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>Scientific experiments must be repeatable and reproducable to be considered scientific. Reproducability in software is optional - software that works but is not reproducible is still successful software. I hope to convince you that the overhead required to create reproducible software is low compared to the benefits that it provides future developers, even if the only future developer is you.</p>

<h2 id="defining-reproducible-software">Defining reproducible software</h2>

<p>It is useful to clarify our definition of reproducibility within the context of software development. Let P<sub>0</sub> represent a stable, compiling build of a codebase that results in a <em>correct</em> program. The reproducibility test for P<sub>0</sub> is as follows:</p>

<blockquote>
  <p>Does the code/documentation for P<sub>0</sub> contain sufficient information to reproduce the <em>correct</em> program from a clean environment? (Yes/No)</p>
</blockquote>

<p>Next, let P<sub>1</sub> represent the code (in the new environment) that has undergone a substantial change that <em>modified the build environment.</em> We can reapply the reproducibilty test to P<sub>1</sub>. The number of times that code passes the reproducibility test can be defined as its reproducibility level [0..N].</p>

<p>It may be useful to name a few of these levels.</p>

<ul>
  <li><em>Irreproducible</em> - Reproducibility level 0; P<sub>0</sub> failed the reproducibility test.</li>
  <li><em>One-time reproducible</em> - Reproducibility level 1; P<sub>0</sub> passed the reproducibility test, but P<sub>1</sub> failed.</li>
  <li><em>Continuously reproducible</em> - Reproducibility level 2+; If P<sub>0</sub> and P<sub>1</sub> pass the reproducibility test then it is indicitave that the code is written in a way that supports reproducibility for future generations of the code.</li>
</ul>

<h2 id="the-continuously-reproducible-mindset">The continuously reproducible mindset</h2>

<p>How many times have you pulled a project from Github only to have it fail to compile?</p>

<blockquote>
  <p>It works on my machine ¯\_(ツ)_/¯</p>
</blockquote>

<p>We can reduce this problem by expanding our mindset to strive for <strong>continuously reproducible</strong> code. The key to creating continuously reproducible code is create a simple workflow that rebuilds the project from a clean environment (preferably Windows, Linux, and OSX). This allows you to isolate undocumented side-effects that can occur in your local development environment (e.g. relying on a tool available locally that is not installed during the build process).</p>

<p>Continuosly reproducible code balances the need to solve the current problem with the need to redeploy the codebase to new systems. If this doesn’t seem worthwhile, then it might be helpful to imagine that your code (P<sub>0</sub>) will be extended by a different developer in a substantial way (P<sub>1</sub>) before it is returned to you for another round of development (P<sub>2</sub>). The time spent during the initial phase of development to create a build process that is easy to replicate across platforms (and modify as needed) will payoff in the long run.</p>

<p>But what if you are the only developer that will ever use this code? I have  found the continuosly reproducible mindset to be helpful in my personal projects for tracking down build-related problems and ensuring that my code works even after long pauses in active development.</p>

<h2 id="measuring-the-longevity-of-a-build">Measuring the longevity of a build</h2>

<p>If a specific build passes the reproducibility test then its longevity can be measured. Longevity is a measure of the period of time between the first time the build passes the reproducibility test and the last time it passes. All builds eventually fail because some dependency of the build process will fail (including the language itself - .NET Framework 3.5 was released in November  2007 but it is no longer available from Microsoft).</p>

<p align="center">
  <img width="600" height="400" src="/assets/images/fight_club.jpg" />
</p>

<p>Longevity is measured for a single build configuration. Namely, P<sub>0</sub> will have a certain longevity, but P<sub>1</sub>’s longevity may be shorter or longer depending on the changes made to its build configuration. Although true longevity can only be calculated after the build fails, developers can make conscious decisions to maximize the expected longevity of their code:</p>
<ul>
  <li>prefer dependencies that offer long term support (e.g. choose .NET 6 LTS even after .NET 7 is released) <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></li>
  <li>prefer dependencies that minimize the number of <a href="https://fsprojects.github.io/Paket/faq.html#What-does-transitive-dependencies-mean">transitive dependencies</a></li>
  <li>specify dependencies using <a href="https://fsprojects.github.io/Paket/nuget-dependencies.html#Pinned-version-constraint">pinned version constraints</a> <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></li>
  <li>if using Docker, build from <a href="https://hub.docker.com/search?q=&amp;type=image&amp;image_filter=official">official base images</a></li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Reproducibility is relatively easy with modern software development tools. The crux of the problem is giving future developers the ability to:</p>
<ol>
  <li>easily recreate the initial development environment across multiple platforms/architectures</li>
  <li>continue to make changes to the code that does not break this process</li>
</ol>

<p>In the next few posts I will describe my approach to reproducibility and demonstrate how to apply them to an existing code base.</p>

<h4 id="footnotes">Footnotes</h4>

<!--

1. Intro
  - need for reproducibility
  - in science
  - in software
  - in machine learning

2. Basic tools
  - Docker (links to learning resources)
  - Gitlab/Github 
  - CI/CD
  - permissive licensing

3. Producing reporducible builds
  - choice of baseline (LTS)
  - provide multiple options (multiple-platforms)
    - local install w/ ci/cd
    - docker-compose local (build)
  - push build complexity to lowest level

4. CI/CD
  - Gitlab runner w/ docker
  - (optional) docker registry

5. Publishing
  - code should be publish to allow someone (most likely yourself) to reproduce it
  - but it shouldnt be required; also provide standalone executables

-->

<!--
https://www.nature.com/articles/s41562-016-0021


The problem
A hallmark of scientific creativity is the ability to see novel and unexpected patterns in data. John Snow's identification of links between cholera and water supply17, Paul Broca's work on language lateralization18 and Jocelyn Bell Burnell's discovery of pulsars19 are examples of breakthroughs achieved by interpreting observations in a new way. However, a major challenge for scientists is to be open to new and important insights while simultaneously avoiding being misled by our tendency to see structure in randomness. The combination of apophenia (the tendency to see patterns in random data), confirmation bias (the tendency to focus on evidence that is in line with our expectations or favoured explanation) and hindsight bias (the tendency to see an event as having been predictable only after it has occurred) can easily lead us to false conclusions20. Thomas Levenson documents the example of astronomers who became convinced they had seen the fictitious planet Vulcan because their contemporary theories predicted its existence21. Experimenter effects are an example of this kind of bias22.

Over-interpretation of noise is facilitated by the extent to which data analysis is rapid, flexible and automated23. In a high-dimensional dataset, there may be hundreds or thousands of reasonable alternative approaches to analysing the same data24,25. For example, in a systematic review of functional magnetic resonance imaging (fMRI) studies, Carp showed that there were almost as many unique analytical pipelines as there were studies26. If several thousand potential analytical pipelines can be applied to high-dimensional data, the generation of false-positive findings is highly likely. For example, applying almost 7,000 analytical pipelines to a single fMRI dataset resulted in over 90% of brain voxels showing significant activation in at least one analysis27.

During data analysis it can be difficult for researchers to recognize P-hacking28 or data dredging because confirmation and hindsight biases can encourage the acceptance of outcomes that fit expectations or desires as appropriate, and the rejection of outcomes that do not as the result of suboptimal designs or analyses. Hypotheses may emerge that fit the data and are then reported without indication or recognition of their post hoc origin7. This, unfortunately, is not scientific discovery, but self-deception29. Uncontrolled, it can dramatically increase the false discovery rate. We need measures to counter the natural tendency of enthusiastic scientists who are motivated by discovery to see patterns in noise.


-->
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Microsoft patches .NET LTS releases for 3 years while current releases are only patched for 18 months. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>While it may seem counterintuitive to limit the available versions of your dependencies, it improves control over the automatic dependency resolver. This is in line with the continuously reproducible mindset and future developers are always free to update the version if they encounter a conflict. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Daniel Felps</name><email>dlfelps@gmail.com</email></author><category term="reproducible" /><category term="net" /><summary type="html"><![CDATA[The next few posts take step back to examine the benefits of creating reproducible software. We will explore: the continuosly reproducible mindset (this post) foundational tools for reproducibility (Exp 03) creating a continuously reproducible .NET project (Exp 04)]]></summary></entry><entry><title type="html">Experiment 01</title><link href="https://dlfelps.github.io/2022/06/06/DOTNET-Publishing-Options.html" rel="alternate" type="text/html" title="Experiment 01" /><published>2022-06-06T00:00:00+00:00</published><updated>2022-06-06T00:00:00+00:00</updated><id>https://dlfelps.github.io/2022/06/06/DOTNET-Publishing-Options</id><content type="html" xml:base="https://dlfelps.github.io/2022/06/06/DOTNET-Publishing-Options.html"><![CDATA[<p>This experiment explores various publishing options associated with .NET, including:</p>
<ul>
  <li>framework-dependent vs self-contained</li>
  <li>Windows vs Linux vs OSX</li>
  <li>and more…</li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>The traditional way to distribute a .NET application is by compiling code (e.g. C#) into bytecode known as <a href="https://en.wikipedia.org/wiki/Common_Intermediate_Language">CIL</a>. This bytecode can then be run by anyone who has installed the .NET runtime environment (also known as <a href="https://docs.microsoft.com/en-us/dotnet/standard/clr">CLR</a>). The process is illustrated below:</p>

<p align="center">
  <img width="416" height="480" src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/71/Overview_of_the_Common_Language_Infrastructure_2015.svg/416px-Overview_of_the_Common_Language_Infrastructure_2015.svg.png" />
</p>

<p>This compilation strategy is known as <a href="https://en.wikipedia.org/wiki/Dynamic_compilation">dynamic compilation</a> and was popularized by the Java Virtual Machine. Some languages like C++ use static compilers that produce native code for a specific platform directly. This code cannot be shared across platforms, but users also do not need to install a runtime environment.</p>

<p>Although the .NET runtime is simple to install, some users may still prefer a “standalone” executable that does not require this extra step. Since .NET 3.0 developers have been able to publish their code as “self-contained” - which means that it includes the runtime environment along with their compiled bytecode. The only real downside is that it creates executables that are larger than they would be otherwise.</p>

<p>This study explores the effect of publishing code as “self-contained” across various platforms and the extent to which the size can be reduced through advanced publishing options.</p>

<h2 id="setup">Setup</h2>

<p>I strive to make all of my experiments reproducible. Please follow the installation instructions below to configure your system to run the experiment.</p>

<ol>
  <li>Install <a href="https://dotnet.microsoft.com/en-us/download">.NET 6.0 SDK</a> (not the Runtime option)</li>
  <li>Obtain the <a href="https://github.com/dlfelps/WaveFunctionCollapse">WaveFunctionCollapse</a> repo; you can either:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/dlfelps/WaveFunctionCollapse.git
</code></pre></div>    </div>
    <p>or <a href="https://github.com/dlfelps/WaveFunctionCollapse/archive/refs/heads/master.zip">download</a> and unzip</p>
  </li>
  <li>Run the provided commands for each experiment (see below)</li>
</ol>

<h2 id="experiment">Experiment</h2>

<h3 id="framework-dependent-vs-self-contained">Framework-dependent vs self-contained</h3>

<p>The first part of the experiment compares two deployment modes. In the framework-dependent distribution mode only the application and third-party assemblies are included; it is assumed that users will have the .NET runtime installed on their system. In the self-contained distribution mode the .NET runtime and runtime libraries included as well.</p>

<p>Another difference between the two modes is that the framework-dependent mode produces a cross-platform binary, which means it can run on any platform. The self-contained option must be created for a specific platform (in this case we use win-x64 but any valid runtime in the <a href="https://docs.microsoft.com/en-us/dotnet/core/rid-catalog">RID Catalog</a> may be chosen).</p>

<p>To run this portion of the experiment execute the following commands within your WaveFunctionCollapse folder (I am using Powershell for Windows):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dotnet publish -c "exp_1a_framework-dependent"
dotnet publish -c "exp_1a_self-contained" -r win-x64 --self-contained true
</code></pre></div></div>
<p>The published folders can be found at</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>..\WaveFunctionCollapse\bin\exp_1a_framework-dependent\net6.0\publish\
..\WaveFunctionCollapse\bin\exp_1a_self-contained\net6.0\win-x64\publish
</code></pre></div></div>
<p>Execution of the created application is different in each case. From the framework-dependent publish folder the entrypoint is the cross-platform binary using the dotnet command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dotnet WaveFunctionCollapse.dll
</code></pre></div></div>
<p>From the self-contained publish folder the entrypoint is simply the platform-specific executable (Windows here):</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./WaveFunctionCollapse.exe
</code></pre></div></div>
<p>We measure the size of the corresponding publish folders to compare the final size of the distributable application in each case.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th style="text-align: center">size (MB)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>framework-dependent (cross-platform)</td>
      <td style="text-align: center">1.53</td>
    </tr>
    <tr>
      <td>self-contained (win-x64 only)</td>
      <td style="text-align: center">68.7</td>
    </tr>
  </tbody>
</table>

<p>The difference does appear to be approximately the size of a binary installation of .NET 6.0 (for Windows is 68.1 MB). But 68 MB barely registers on a 500 GB hard drive. My bigger concern is that self-contained distributions limit the systems that can use it since they are platform specific. In the next experiment we look at platforms besides Windows. <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<h3 id="varying-the-platform-of-self-contained-releases">Varying the platform of self-contained releases</h3>

<p>In this part of the experiment we determine the extent to which the target platform changes the size of the publish folder. To run this portion of the experiment execute the following commands within your WaveFunctionCollapse folder:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dotnet publish -c "exp_1b_linux"  -r linux-x64 --self-contained true
dotnet publish -c "exp_1b_osx_x64"  -r osx-x64 --self-contained true
dotnet publish -c "exp_1b_osx12_arm"  -r osx.12-arm64 --self-contained true
</code></pre></div></div>
<p>I measured the size of the corresponding publish folders and also included the results from the self-contained win-x64 from the previous section.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th style="text-align: center">size (MB)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>win-x64</td>
      <td style="text-align: center">68.7</td>
    </tr>
    <tr>
      <td>linux-x64</td>
      <td style="text-align: center">68.5</td>
    </tr>
    <tr>
      <td>osx-x64</td>
      <td style="text-align: center">68.5</td>
    </tr>
    <tr>
      <td>osx12-arm</td>
      <td style="text-align: center">75.0</td>
    </tr>
  </tbody>
</table>

<p>There is no significant difference between the sizes of these various platforms. They are all approximately the size of the original application code plus the size of the binary installation of .NET 6.0 for the corresponding platform.</p>

<h3 id="trimming">Trimming</h3>

<p>To finish out this experiment I wanted to explore one of the advanced publishing options that dotnet provides - trimming. When you enable trimming the compiler tries to reduce deployment size by including only the minimum  subset of the framework assemblies that are needed to run the application. The unused parts of the framework are trimmed from the packaged application. But there is a risk that the compiler miscalculates which parts are necessary during build time causing a failure at run time.</p>

<p>To run this portion of the experiment execute the following commands within your WaveFunctionCollapse folder:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dotnet publish -c "exp_1c_windows"  -r win-x64 --self-contained true -p:PublishTrimmed=true
dotnet publish -c "exp_1c_linux"  -r linux-x64 --self-contained true -p:PublishTrimmed=true
dotnet publish -c "exp_1c_osx_x64"  -r osx-x64 --self-contained true -p:PublishTrimmed=true
dotnet publish -c "exp_1c_osx12_arm"  -r osx.12-arm64 --self-contained true -p:PublishTrimmed=true
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th> </th>
      <th style="text-align: center">original size (MB)</th>
      <th style="text-align: center">reduced size (MB)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>win-x64</td>
      <td style="text-align: center">68.7</td>
      <td style="text-align: center">22.1</td>
    </tr>
    <tr>
      <td>linux-x64</td>
      <td style="text-align: center">68.5</td>
      <td style="text-align: center">23.8</td>
    </tr>
    <tr>
      <td>osx-x64</td>
      <td style="text-align: center">68.5</td>
      <td style="text-align: center">22.7</td>
    </tr>
    <tr>
      <td>osx12-arm</td>
      <td style="text-align: center">75.0</td>
      <td style="text-align: center">21.9</td>
    </tr>
  </tbody>
</table>

<p>The results show that the reduced size is about one third of the original size. But the risk that the application <em>may</em> fail at runtime does not seem worth the memory savings for most applications. However in this case I was able to verify that the Windows and Linux distributions worked correctly (OSX was not tested).</p>

<h2 id="limitations-of-study">Limitations of study</h2>

<p>The results shown above represent an experiment for a single code base. You may get different results for your own code (especially when trimming). If you do repeat this study on a different code base I would appreciate it if you would share the results for comparison!</p>

<h2 id="conclusion">Conclusion</h2>

<p>.NET makes it amazingly simple to publish code that works on almost any device. In order to share your application with the widest audience I recommend publishing both the framework-dependent and (untrimmed) self-contained versions for all major platforms. I do not generally recommend trimming unless you are able to thoroughly test the created executables.</p>

<h3 id="references">References</h3>

<ol>
  <li><a href="https://docs.microsoft.com/en-us/dotnet/core/deploying/">.NET application publishing overview</a></li>
  <li><a href="https://github.com/mxgmn/WaveFunctionCollapse">WaveFunctionCollapse</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Common_Language_Infrastructure">CLI</a></li>
</ol>

<h3 id="footnotes">Footnotes</h3>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>By default the framework-dependent mode creates both a cross-platform binary and a platform-specific executable that targets the current platform. In my case the publish folder included a platform-specific file called WaveFunctionCollapse.exe (since I use Windows). This unnecessary  file was removed before the folder size was measured. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Daniel Felps</name><email>dlfelps@gmail.com</email></author><category term="net" /><summary type="html"><![CDATA[This experiment explores various publishing options associated with .NET, including: framework-dependent vs self-contained Windows vs Linux vs OSX and more…]]></summary></entry><entry><title type="html">Welcome to my blog!</title><link href="https://dlfelps.github.io/2022/06/04/My-First-Post.html" rel="alternate" type="text/html" title="Welcome to my blog!" /><published>2022-06-04T00:00:00+00:00</published><updated>2022-06-04T00:00:00+00:00</updated><id>https://dlfelps.github.io/2022/06/04/My-First-Post</id><content type="html" xml:base="https://dlfelps.github.io/2022/06/04/My-First-Post.html"><![CDATA[<p>My goal for this site is to document the “experiments” that I perform while exploring various computer science topics. I hope to include future posts on the following topics:</p>

<ul>
  <li>.NET</li>
  <li>domain driven design</li>
  <li>software architecture</li>
</ul>

<p>If you have any suggestions or comments please email me at <a href="mailto:dlfelps@gmail.com">dlfelps@gmail.com</a>.</p>]]></content><author><name>Daniel Felps</name><email>dlfelps@gmail.com</email></author><summary type="html"><![CDATA[My goal for this site is to document the “experiments” that I perform while exploring various computer science topics. I hope to include future posts on the following topics:]]></summary></entry></feed>